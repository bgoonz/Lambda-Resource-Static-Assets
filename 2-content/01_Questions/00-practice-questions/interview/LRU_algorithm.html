<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>LRU_algorithm</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="detailed-analysis-of-lru-algorithm">Detailed Analysis of LRU Algorithm</h1>
<p><strong>Translator: <a href="https://github.com/youyun">youyun</a></strong></p>
<p><strong>Author: <a href="https://github.com/labuladong">labuladong</a></strong></p>
<h3 id="what-is-lru-algorithm">1. What is LRU Algorithm</h3>
<p>It is just a cache clean-up strategy.</p>
<p>A computer has limited memory cache. If the cache is full, some contents need to be removed from cache to provide space for new content. However, which part of the cache should be removed? We hope to remove not so useful contents, while leaving useful contents untouched for future usage. So the question is, what are the criteria to determine if the data is <em>useful</em> or not?</p>
<p>LRU (Least Recently Used) cache clean-up algorithm is a common strategy. According to the name, the latest used data should be <em>useful</em>. Hence, when the memory cache is full, we should prioritize removing those data that haven’t been used for long are not useful.</p>
<p>For example, an Android phone can run apps in the background. If I opened in sequence: Settings, Phone Manager, and Calendar, their order in the background will be shown as following:</p>
<figure>
<img src="../pictures/LRU/1.jpg" alt="jietu" /><figcaption>jietu</figcaption>
</figure>
<p>If I switch to Settings now, Settings will be brought to the first:</p>
<figure>
<img src="../pictures/LRU/2.jpg" alt="jietu" /><figcaption>jietu</figcaption>
</figure>
<p>Assume that my phone only allows me to open 3 apps simultaneously, then the cache is already full by now. If I open another app, Clock, then I have to close another app to free up space for Clock. Which one should be closed?</p>
<p>According to LRU strategy, the lowest app, Phone Manager, should be closed, because it is the longest unused app. Afterwards, the newly opened app will be on the top:</p>
<figure>
<img src="../pictures/LRU/3.jpg" alt="jietu" /><figcaption>jietu</figcaption>
</figure>
<p>Now you should understand LRU (Least Recently Used) strategy. There are some other strategies available, for example, LFU (Least Frequently Used) strategy, etc. Different strategies can be applied in different use cases. We’ll focus on LRU in this article.</p>
<h3 id="lru-algorithm-description">2. LRU Algorithm Description</h3>
<p>LRU algorithm is actually about data structure design: 1. Take a parameter, <code>capacity</code>, as the maximum size; then 2. Implement two APIs: * <code>put(key, val)</code>: to store key-value pair * <code>get(key)</code>: return the value associated with the key; return -1 if the key doesn’t exist. 3. The time complexity for both <code>get</code> and <code>put</code> should be <strong>O(1)</strong>.</p>
<p>Let’s use an example to understand how the LRU algorithm works.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="co">/* Cache capacity is 2 */</span></a>
<a class="sourceLine" id="cb1-2" title="2">LRUCache cache = <span class="kw">new</span> LRUCache(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">// Assume the cache is an queue</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">// The head is on the left, while the tail is on the right</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">// The latest used is at the head, while the longest unused is at the tail</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">// Bracket represents key-value pair, (key, val)</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">cache.put(<span class="dv">1</span>, <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">// cache = [(1, 1)]</span></a>
<a class="sourceLine" id="cb1-10" title="10">cache.put(<span class="dv">2</span>, <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">// cache = [(2, 2), (1, 1)]</span></a>
<a class="sourceLine" id="cb1-12" title="12">cache.get(<span class="dv">1</span>);       <span class="co">// return 1</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co">// cache = [(1, 1), (2, 2)]</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co">// Remarks: because key 1 is visited, move it to the head</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">// Return the value, 1, associated with key 1</span></a>
<a class="sourceLine" id="cb1-16" title="16">cache.put(<span class="dv">3</span>, <span class="dv">3</span>);</a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">// cache = [(3, 3), (1, 1)]</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="co">// Remarks: the memory capacity is full</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">// We need to remove some contents to free up space</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">// Removal will prioritize longest unused data, which is at the tail</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="co">// Afterwards, insert the new data at the head</span></a>
<a class="sourceLine" id="cb1-22" title="22">cache.get(<span class="dv">2</span>);       <span class="co">// return -1 (not found)</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co">// cache = [(3, 3), (1, 1)]</span></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="co">// Remarks: key 2 does not exist in the cache</span></a>
<a class="sourceLine" id="cb1-25" title="25">cache.put(<span class="dv">1</span>, <span class="dv">4</span>);    </a>
<a class="sourceLine" id="cb1-26" title="26"><span class="co">// cache = [(1, 4), (3, 3)]</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">// Remarks: key 1 exists</span></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="co">// Overwrite with new value 4</span></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="co">// Don&#39;t forget to bring the key to the head</span></a></code></pre></div>
<h3 id="lru-algorithm-design">3. LRU Algorithm Design</h3>
<p>Through analysis of the above steps, if time complexity for <code>put</code> and <code>get</code> are both O(1), we can summarize features of this cache data structure: fast search, fast insertion, fast deletion, and ordered. - <em>Ordered</em>: Obviously, the data has to be ordered to distinguish recently used and longest unused. - <em>Fast Search</em>: We also need to be able to find if a key exists in the cache. - <em>Fast Deletion</em>: If the cache is full, we need to delete the last element. - <em>Fast Insertion</em>: We need to insert the data to the head upon each visit.</p>
<p>Which data structure can fulfill the above requirements? Hash table can search fast, but the data is unordered. Data in linked list is ordered, and can be inserted or deleted fast, but is hard to search. Combining these two, we can come up with a new data structure: <strong>hash linked list</strong>.</p>
<p>The core data structure of LRU cache algorithm is hash linked list, a combination of doubly linked list and hash table. Here is how the data structure looks:</p>
<figure>
<img src="../pictures/LRU/5.jpg" alt="HashLinkedList" /><figcaption>HashLinkedList</figcaption>
</figure>
<p>The idea is simple - using a hash table to provide the ability of fast search to linked list. Think again about the previous example, isn’t this data structure the perfect solution for LRU cache data structure?</p>
<p>Some audience may wonder, why doubly linked list? Can’t single linked list work? Since key exists in hash table, why do we have to store the key-value pairs in linked list instead of values only?</p>
<p>The answers only afloat when we actually do it. We can only understand the rationale behind the design after we implement the LRU algorithm ourselves. Let’s look at the code.</p>
<h3 id="implementation">4. Implementation</h3>
<p>A lot of programming languages have built-in hash linked list, or LRU-alike functions. To help understand the details of the LRU algorithm, let’s use Java to reinvent the wheel.</p>
<p>First, define the <code>Node</code> class of doubly linked list. Assuming both <code>key</code> and <code>val</code> are of type <code>int</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> <span class="bu">Node</span> {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="kw">public</span> <span class="dt">int</span> key, val;</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">public</span> <span class="bu">Node</span> next, prev;</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="kw">public</span> <span class="bu">Node</span>(<span class="dt">int</span> k, <span class="dt">int</span> v) {</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="kw">this</span>.<span class="fu">key</span> = k;</a>
<a class="sourceLine" id="cb2-6" title="6">        <span class="kw">this</span>.<span class="fu">val</span> = v;</a>
<a class="sourceLine" id="cb2-7" title="7">    }</a>
<a class="sourceLine" id="cb2-8" title="8">}</a></code></pre></div>
<p>Using our <code>Node</code> class, implement a doubly linked list with the necessary APIs (the time complexity of these functions are all O(1)):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> DoubleList {  </a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co">// Add x at the head, time complexity O(1)</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">addFirst</span>(<span class="bu">Node</span> x);</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="co">// Delete node x in the linked list (x is guaranteed to exist)</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="co">// Given a node in a doubly linked list, time complexity O(1)</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">remove</span>(<span class="bu">Node</span> x);</a>
<a class="sourceLine" id="cb3-8" title="8">    </a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="co">// Delete and return the last node in the linked list, time complexity O(1)</span></a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="kw">public</span> <span class="bu">Node</span> <span class="fu">removeLast</span>();</a>
<a class="sourceLine" id="cb3-11" title="11">    </a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="co">// Return the length of the linked list, time complexity O(1)</span></a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">size</span>();</a>
<a class="sourceLine" id="cb3-14" title="14">}</a></code></pre></div>
<p>P.S. This is the typical interface of a doubly linked list. In order to focus on the LRU algorithm, we’ll skip the detailed implementation of functions in this class.</p>
<p>Now we can answer the question, why we have to use a doubly linked list. In order to delete a node, we not only need to get the pointer of the node itself, but also need to update the node before and the node after. Only using a doubly linked list, we can guarantee the time complexity is O(1).</p>
<p>With the doubly linked list, we just need to use it in with a hash table in the LRU algorithm. Let’s sort out the logic with pseudo code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// key associated with Node(key, val)</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="bu">HashMap</span>&lt;<span class="bu">Integer</span>, <span class="bu">Node</span>&gt; map;</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></a>
<a class="sourceLine" id="cb4-4" title="4">DoubleList cache;</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="dt">int</span> <span class="fu">get</span>(<span class="dt">int</span> key) {</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="kw">if</span> (key does not exist) {</a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="kw">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb4-9" title="9">    } <span class="kw">else</span> {        </a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="fu">bring</span> (key, val) to the head;</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">return</span> val;</a>
<a class="sourceLine" id="cb4-12" title="12">    }</a>
<a class="sourceLine" id="cb4-13" title="13">}</a>
<a class="sourceLine" id="cb4-14" title="14"></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="dt">void</span> <span class="fu">put</span>(<span class="dt">int</span> key, <span class="dt">int</span> val) {</a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="bu">Node</span> x = <span class="kw">new</span> <span class="bu">Node</span>(key, val);</a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="kw">if</span> (key exists) {</a>
<a class="sourceLine" id="cb4-18" title="18">        delete the old node;</a>
<a class="sourceLine" id="cb4-19" title="19">        insert the <span class="kw">new</span> node x to the head;</a>
<a class="sourceLine" id="cb4-20" title="20">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-21" title="21">        <span class="kw">if</span> (cache is full) {</a>
<a class="sourceLine" id="cb4-22" title="22">            delete the last node in the linked list;</a>
<a class="sourceLine" id="cb4-23" title="23">            delete the associated value in map;</a>
<a class="sourceLine" id="cb4-24" title="24">        } </a>
<a class="sourceLine" id="cb4-25" title="25">        insert the <span class="kw">new</span> node x to the head;</a>
<a class="sourceLine" id="cb4-26" title="26">        associate the <span class="kw">new</span> node x with key in map;</a>
<a class="sourceLine" id="cb4-27" title="27">    }</a>
<a class="sourceLine" id="cb4-28" title="28">}</a></code></pre></div>
<p>If you can understand the logic above, it’s easy to translate to code:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> LRUCache {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="co">// key -&gt; Node(key, val)</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">private</span> <span class="bu">HashMap</span>&lt;<span class="bu">Integer</span>, <span class="bu">Node</span>&gt; map;</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="co">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">private</span> DoubleList cache;</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="co">// Max capacity</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">private</span> <span class="dt">int</span> cap;</a>
<a class="sourceLine" id="cb5-8" title="8">    </a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">public</span> <span class="fu">LRUCache</span>(<span class="dt">int</span> capacity) {</a>
<a class="sourceLine" id="cb5-10" title="10">        <span class="kw">this</span>.<span class="fu">cap</span> = capacity;</a>
<a class="sourceLine" id="cb5-11" title="11">        map = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb5-12" title="12">        cache = <span class="kw">new</span> <span class="fu">DoubleList</span>();</a>
<a class="sourceLine" id="cb5-13" title="13">    }</a>
<a class="sourceLine" id="cb5-14" title="14">    </a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">get</span>(<span class="dt">int</span> key) {</a>
<a class="sourceLine" id="cb5-16" title="16">        <span class="kw">if</span> (!map.<span class="fu">containsKey</span>(key))</a>
<a class="sourceLine" id="cb5-17" title="17">            <span class="kw">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb5-18" title="18">        <span class="dt">int</span> val = map.<span class="fu">get</span>(key).<span class="fu">val</span>;</a>
<a class="sourceLine" id="cb5-19" title="19">        <span class="co">// Using put method to bring it forward to the head</span></a>
<a class="sourceLine" id="cb5-20" title="20">        <span class="fu">put</span>(key, val);</a>
<a class="sourceLine" id="cb5-21" title="21">        <span class="kw">return</span> val;</a>
<a class="sourceLine" id="cb5-22" title="22">    }</a>
<a class="sourceLine" id="cb5-23" title="23">    </a>
<a class="sourceLine" id="cb5-24" title="24">    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">put</span>(<span class="dt">int</span> key, <span class="dt">int</span> val) {</a>
<a class="sourceLine" id="cb5-25" title="25">        <span class="co">// Initialize new node x</span></a>
<a class="sourceLine" id="cb5-26" title="26">        <span class="bu">Node</span> x = <span class="kw">new</span> <span class="bu">Node</span>(key, val);</a>
<a class="sourceLine" id="cb5-27" title="27">        </a>
<a class="sourceLine" id="cb5-28" title="28">        <span class="kw">if</span> (map.<span class="fu">containsKey</span>(key)) {</a>
<a class="sourceLine" id="cb5-29" title="29">            <span class="co">// Delete the old node, add to the head</span></a>
<a class="sourceLine" id="cb5-30" title="30">            cache.<span class="fu">remove</span>(map.<span class="fu">get</span>(key));</a>
<a class="sourceLine" id="cb5-31" title="31">            cache.<span class="fu">addFirst</span>(x);</a>
<a class="sourceLine" id="cb5-32" title="32">            <span class="co">// Update the corresponding record in map</span></a>
<a class="sourceLine" id="cb5-33" title="33">            map.<span class="fu">put</span>(key, x);</a>
<a class="sourceLine" id="cb5-34" title="34">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-35" title="35">            <span class="kw">if</span> (cap == cache.<span class="fu">size</span>()) {</a>
<a class="sourceLine" id="cb5-36" title="36">                <span class="co">// Delete the last node in the linked list</span></a>
<a class="sourceLine" id="cb5-37" title="37">                <span class="bu">Node</span> last = cache.<span class="fu">removeLast</span>();</a>
<a class="sourceLine" id="cb5-38" title="38">                map.<span class="fu">remove</span>(last.<span class="fu">key</span>);</a>
<a class="sourceLine" id="cb5-39" title="39">            }</a>
<a class="sourceLine" id="cb5-40" title="40">            <span class="co">// Add to the head</span></a>
<a class="sourceLine" id="cb5-41" title="41">            cache.<span class="fu">addFirst</span>(x);</a>
<a class="sourceLine" id="cb5-42" title="42">            map.<span class="fu">put</span>(key, x);</a>
<a class="sourceLine" id="cb5-43" title="43">        }</a>
<a class="sourceLine" id="cb5-44" title="44">    }</a>
<a class="sourceLine" id="cb5-45" title="45">}</a></code></pre></div>
<p>This can answer the previous question, why we need to store key-value pair in the linked list, instead of value only. Pay attention to the block of code below:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">if</span> (cap == cache.<span class="fu">size</span>()) {</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="co">// Delete the last node</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="bu">Node</span> last = cache.<span class="fu">removeLast</span>();</a>
<a class="sourceLine" id="cb6-4" title="4">    map.<span class="fu">remove</span>(last.<span class="fu">key</span>);</a>
<a class="sourceLine" id="cb6-5" title="5">}</a></code></pre></div>
<p>If the cache is full, we not only need to delete the last node, but also need to delete the key in the map, where we can only get the key through the node. If we only store value in a node, we can’t get the key, and hence, can’t delete the key from the map.</p>
<p>Till now, you should have understood the idea and implementation of LRU algorithm. One common mistake is to update associated entries in the hash table when you deal with nodes in the linked list.</p>
</body>
</html>
