<!DOCTYPE html>
<html>
    <head>
        <title>DevOps : Recursion Problems</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">DevOps</a></span>
                            </li>
                                                    <li>
                                <span><a href="DevOps-Home_603226548.html">DevOps Home</a></span>
                            </li>
                                                    <li>
                                <span><a href="Tutorials_278921431.html">Tutorials</a></span>
                            </li>
                                                    <li>
                                <span><a href="Java-Problems_858619905.html">Java Problems</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            DevOps : Recursion Problems
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Nicholas Guner</span>, last modified on Feb 04, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <style type='text/css'>/*<![CDATA[*/
div.rbtoc1613190976647 {padding: 0px;}
div.rbtoc1613190976647 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1613190976647 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1613190976647'>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-BinarySearch'>BinarySearch</a></li>
<li><a href='#RecursionProblems-FindMin'>FindMin</a></li>
<li><a href='#RecursionProblems-EditDistance'>EditDistance</a></li>
<li><a href='#RecursionProblems-EggDrop'>EggDrop</a></li>
<li><a href='#RecursionProblems-Elevator'>Elevator</a></li>
<li><a href='#RecursionProblems-Fibonacci'>Fibonacci</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-fib'>fib</a></li>
<li><a href='#RecursionProblems-fibWithMemoization'>fibWithMemoization</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-SeealsoStairWalk'>See also StairWalk</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#RecursionProblems-IslandCount'>IslandCount</a></li>
<li><a href='#RecursionProblems-FloodFill'>FloodFill</a></li>
<li><a href='#RecursionProblems-GameStrategy'>GameStrategy</a></li>
<li><a href='#RecursionProblems-GenNumberWithSwaps'>GenNumberWithSwaps</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-maxNumberWithSwaps'>maxNumberWithSwaps</a></li>
<li><a href='#RecursionProblems-minNumberWithSwaps'>minNumberWithSwaps</a></li>
</ul>
</li>
<li><a href='#RecursionProblems-HanoiTower'>HanoiTower</a></li>
<li><a href='#RecursionProblems-Josephus'>Josephus</a></li>
<li><a href='#RecursionProblems-KnightTour'>KnightTour</a></li>
<li><a href='#RecursionProblems-LinkedList'>LinkedList</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-reverse'>reverse</a></li>
<li><a href='#RecursionProblems-nthToLast'>nthToLast</a></li>
</ul>
</li>
<li><a href='#RecursionProblems-MakeChange'>MakeChange</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-makeChange'>makeChange</a></li>
<li><a href='#RecursionProblems-numberOfWaysToAddUp'>numberOfWaysToAddUp</a></li>
<li><a href='#RecursionProblems-numberOfWaysToAddUpWithPrint'>numberOfWaysToAddUpWithPrint</a></li>
<li><a href='#RecursionProblems-canGetExactChange'>canGetExactChange</a></li>
</ul>
</li>
<li><a href='#RecursionProblems-Maze'>Maze</a></li>
<li><a href='#RecursionProblems-NSumOrProduct'>NSumOrProduct</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-generateNSum'>generateNSum</a></li>
<li><a href='#RecursionProblems-generateNProduct'>generateNProduct</a></li>
</ul>
</li>
<li><a href='#RecursionProblems-NumericOperations'>NumericOperations</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-gcd'>gcd</a></li>
<li><a href='#RecursionProblems-add'>add</a></li>
<li><a href='#RecursionProblems-multiply'>multiply</a></li>
<li><a href='#RecursionProblems-exponent'>exponent</a></li>
<li><a href='#RecursionProblems-toBinary'>toBinary</a></li>
</ul>
</li>
<li><a href='#RecursionProblems-Palindrome'>Palindrome</a></li>
<li><a href='#RecursionProblems-PhoneNumbers'>PhoneNumbers</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-countPhoneCombinationsWithKnight'>countPhoneCombinationsWithKnight</a></li>
<li><a href='#RecursionProblems-keepPhoneNumbersWithKnight'>keepPhoneNumbersWithKnight</a></li>
</ul>
</li>
<li><a href='#RecursionProblems-PlaceQueens'>PlaceQueens</a></li>
<li><a href='#RecursionProblems-PowerSet'>PowerSet</a></li>
<li><a href='#RecursionProblems-RemoveAdjacentDups'>RemoveAdjacentDups</a></li>
<li><a href='#RecursionProblems-ReverseStack'>ReverseStack</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-reverse.1'>reverse</a></li>
<li><a href='#RecursionProblems-insertAtBottom'>insertAtBottom</a></li>
</ul>
</li>
<li><a href='#RecursionProblems-RodCutting'>RodCutting</a></li>
<li><a href='#RecursionProblems-StairWalk'>StairWalk</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-countWays'>countWays</a></li>
<li><a href='#RecursionProblems-countWaysWithMemoization'>countWaysWithMemoization</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-SeealsoFibonacci'>See also Fibonacci</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#RecursionProblems-StringPermutations'>StringPermutations</a></li>
<li><a href='#RecursionProblems-StringWildMatch'>StringWildMatch</a></li>
<li><a href='#RecursionProblems-Subsequence'>Subsequence</a></li>
<li><a href='#RecursionProblems-Sudoku'>Sudoku</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-solve'>solve</a></li>
<li><a href='#RecursionProblems-isValid'>isValid</a></li>
</ul>
</li>
<li><a href='#RecursionProblems-TravellingSalesman'>TravellingSalesman</a></li>
<li><a href='#RecursionProblems-ValidParens'>ValidParens</a></li>
<li><a href='#RecursionProblems-WordBreak'>WordBreak</a>
<ul class='toc-indentation'>
<li><a href='#RecursionProblems-wordBreak'>wordBreak</a></li>
<li><a href='#RecursionProblems-wordBreakWithMemoization'>wordBreakWithMemoization</a></li>
</ul>
</li>
</ul>
</div><h2 id="RecursionProblems-BinarySearch">BinarySearch</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>BinarySearch</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static&lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] a, T val)
{
    return binarySearch(a, val, 0, a.length - 1);
}


private static&lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] a, T val, int start, int end)
{
    if(end &lt; start)
    {
        return -1;
    }
    int mid = (start + end) / 2;
    T midVal = a[mid];
    if(midVal.compareTo(val) == 0)
    {
        return mid;
    }
    else if(midVal.compareTo(val) == -1)
    {
        start = mid + 1;
    }
    else
    {
        end = mid - 1;
    }
    return binarySearch(a, val, start, end);
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    //             0  1  2  3  4   5   6   7   8   9
    Integer[] a = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    boolean check = binarySearch(a, 1) == 0;
    check = binarySearch(a, 15) == 7;
    if(!check)
    {
        return false;
    }
    check = binarySearch(a, 10) == -1;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p><p /></td></tr></tbody></table></div><h2 id="RecursionProblems-FindMin">FindMin</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>FindMin</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Returns the smallest number in array that has been rotated
For example - Array {3,4,5,6,1,2} returns 1
Input array was originally sorted in increasing orders
Must have O(log n) runtime
Input array does not have any duplicates</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static int findMinInRotatedArrayWithBinarySearch(int[] a)
{
    if(a == null)
    {
        throw new IllegalArgumentException(&quot;Bad input&quot;);
    }
    return findMin(a, 0, a.length - 1);
}

private static int findMin(int[] a, int left, int right)
{
    if (left == right || a[left] &lt; a[right])
    {
        return a[left];
    }
    if(right - left == 1)
    {
        return Math.min(a[left], a[right]);
    }
    int mid = (left + right) / 2;
    if(a[mid] &gt; a[left])
    {
        return findMin(a, mid, right);
    }
    else
    {
        return findMin(a, left, mid);
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = findMinInRotatedArray(new int[]{3,4,5,6,1,2}) == 1
                    &amp;&amp; findMinInRotatedArray(new int[]{4,1,2,3}) == 1
                    &amp;&amp; findMinInRotatedArray(new int[]{1,2,3,4,5,6}) == 1;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-EditDistance">EditDistance</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1094.0px;"/><col style="width: 517.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>EditDistance</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int editDistance(String s1, String s2)
{
    return editDistance(s1, s2, s1.length(), s2.length());
}


private static int editDistance(String s1, String  s2, int len1, int len2)
{
    if(len1 == 0)
    {
        return len2;
    }
    if(len2 == 0)
    {
        return len1;
    }
    if(s1.charAt(len1 - 1) == s2.charAt((len2 - 1)))
    {
        return editDistance(s1, s2, len1 - 1, len2 - 1);
    }
    int d1 = editDistance(s1, s2, len1, len2 - 1);
    int d2 = editDistance(s1, s2, len1 -1, len2);
    int d3 = editDistance(s1, s2, len1 -1, len2 - 1);
    return 1 + min3(d1, d2, d3);
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    String s1 = &quot;sunday&quot;;
    String s2 = &quot;saturday&quot;;
    boolean check = editDistance(s1, s2) == 3;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>Return <code>1 + min3(d1, d2, d3)</code></p></li></ol><h2 id="RecursionProblems-EggDrop">EggDrop<br/></h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1115.0px;"/><col style="width: 496.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>EggDrop</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int drop(int topFloor, int eggs)
{
    if(eggs == 1 || topFloor == 0 || topFloor == 1)
    {
        return topFloor;
    }
    int min = Integer.MAX_VALUE;
    for(int currentFloor = 1; currentFloor &lt;= topFloor; ++ currentFloor)
    {
        int option1 = drop(currentFloor - 1, eggs - 1);
        int option2 = drop(topFloor - currentFloor, eggs);
        int max = Math.max(option1, option2);
        min = Math.min(min, max + 1);
    }
    return min;
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = drop(28, 2) == 7;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-Elevator">Elevator<br/></h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 889.0px;"/><col style="width: 722.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>Elevator</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int capacity(int limit, int[] weights)
{
    //  We have an elevator with stated capacity and people with various weights who want to get on.
    //  The objective is to maximize capacity without exceeding it.
    //  Example:
    //      Capacity:   750
    //      Weights:    [420, 200, 150, 780, 350]
    //      Max:        700 = 200 + 150 + 350
    //  NOTE:
    //  1.  Weights array does not need to be sorted
    //  2.  Same as knapsack problem but easier to understand
    return capacity(limit, weights, weights.length - 1);
}


private static int capacity(int limit, int[] weights, int index)
{
    if(limit == 0 || index &lt; 0)
    {
        return 0;
    }
    if(weights[index] &gt; limit)
    {
        return capacity(limit, weights, index - 1);
    }
    else
    {
        int include = weights[index] + capacity(limit - weights[index], weights, index - 1);
        int exclude = capacity(limit, weights, index - 1);
        return Math.max(include, exclude);
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = capacity(750, new int[] {420, 200, 150, 780, 350}) == 700;
    if(!check)
    {
        return false;
    }
    check = capacity(800, new int[] {420, 200, 150, 780, 350}) == 780;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>Note the use of <code>index - 1</code> for <code>include</code></p></li><li><p>Same problem as knapsack and spending most time watching movies during a flight.</p></li><li><p>Array of <code>weights </code>does not need to be sorted</p></li></ol><h2 id="RecursionProblems-Fibonacci">Fibonacci</h2><h3 id="RecursionProblems-fib"><code>fib</code></h3><h3 id="RecursionProblems-fibWithMemoization"><code>fibWithMemoization</code></h3><h4 id="RecursionProblems-SeealsoStairWalk">See also <a href="https://nickguner.atlassian.net/wiki/spaces/DEV/pages/875528233/Recursion+Problems#StairWalk" rel="nofollow">StairWalk</a></h4><p /><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 822.0px;"/><col style="width: 789.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>Fibonacci</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int fib(int n)
{
    if(n &lt; 0)
    {
        return -1;
    }
    else if(n &lt; 2)
    {
        return n;
    }
    else
    {
        return fib(n - 1) + fib(n - 2);
    }
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int fibWithMemoization(int n)
{
    if(n &lt; 1)
    {
        return n;
    }
    int[] dp = new int[n + 1];
    Arrays.fill(dp, -1);
    dp[0] = 0;
    if(n &gt; 0)
    {
        dp[1] = 1;
    }
    return fibWithMemoization(n, dp);
}

private static int fibWithMemoization(int n, int[] dp)
{
    if(dp[n] == -1)
    {
        dp[n] = fibWithMemoization(n - 1, dp) +
                fibWithMemoization(n - 2, dp);
    }
    return dp[n];
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = fib(0) == 0;
    if(!check)
    {
        return false;
    }
    check = fib(1) == 1;
    if(!check)
    {
        return false;
    }
    check = fib(2) == 1;
    if(!check)
    {
        return false;
    }
    check = fib(14) == 377;
    if(!check)
    {
        return false;
    }
    check = fibWithMemoization(0) == 0;
    if(!check)
    {
        return false;
    }
    check = fibWithMemoization(1) == 1;
    if(!check)
    {
        return false;
    }
    check = fibWithMemoization(2) == 1;
    if(!check)
    {
        return false;
    }
    check = fibWithMemoization(14) == 377;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>For momoization, make sure to fill <code>dp </code>array with <code>-1</code> since <code>0</code> is a legitimate value for Fibonacci, but not for <code>StairWalk</code>.</p></li><li><p>For memoization, public function creates <code>dp </code>array and sets it with initial values, recursive function checks base cases and sets <code>dp[n]</code> if it was equal to -1.</p></li></ol><h2 id="RecursionProblems-IslandCount">IslandCount</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>IslandCount</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int countIslands(int[][] grid)
{
    int count = 0;
    for(int i = 0; i &lt; grid.length; ++i)
    {
        for(int j = 0; j &lt; grid[0].length; ++j)
        {
            if(grid[i][j] == 1)
            {
                count++;
                merge(grid, i, j);
            }
        }
    }
    return count;
}


private static void merge(int[][] grid, int x, int y)
{
    if(x &lt; 0 || x &gt;= grid.length || y &lt; 0 || y &gt;= grid[0].length || grid[x][y] == 0)
    {
        return;
    }
    grid[x][y] = 0;
    merge(grid, x + 1, y);
    merge(grid, x - 1, y);
    merge(grid, x, y + 1);
    merge(grid, x, y - 1);
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    int[][] data = new int[][]{
            {1, 1, 0, 1},
            {0, 1, 0, 0},
            {0, 1, 0, 0},
            {1, 0, 1, 1},
            {1, 0, 1, 0}
    };
    boolean check = countIslands(data) == 4;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-FloodFill">FloodFill</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 879.0px;"/><col style="width: 732.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>FloodFill</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Filling [3,3] with 2 will result in
{0, 0, 0, 1, 0, 0, 0},          {0, 0, 0, 1, 2, 2, 2},
{0, 0, 0, 1, 0, 0, 0},          {0, 0, 0, 1, 2, 2, 2},
{0, 0, 1, 0, 0, 0, 0},          {0, 0, 1, 2, 2, 2, 2},
{1, 1, 0, 0, 0, 1, 1},          {1, 1, 2, 2, 2, 1, 1},
{0, 0, 0, 0, 1, 0, 0},          {2, 2, 2, 2, 1, 0, 0},
{0, 0, 0, 1, 0, 0, 0},          {2, 2, 2, 1, 0, 0, 0},
{0, 0, 0, 1, 0, 0, 0},          {2, 2, 2, 1, 0, 0, 0},</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static void floodFill(int[][] grid, int[] pos, int toVal)
{
    int row = pos[0], col = pos[1];
    int fromVal = grid[row][col];
    floodFill(grid, row, col, fromVal, toVal);
}
static private void floodFill(int[][] grid, int row, int col, int fromVal, int toVal)
{
    if(row &lt; 0 || row &gt;= grid.length || col &lt; 0 || col &gt;= grid.length || grid[row][col] != fromVal)
    {
        return;
    }
    grid[row][col] = toVal;
    floodFill(grid, row + 1, col, fromVal, toVal);
    floodFill(grid, row - 1, col, fromVal, toVal);
    floodFill(grid, row, col + 1, fromVal, toVal);
    floodFill(grid, row, col - 1, fromVal, toVal);
}</pre>
</div></div><p><br/></p></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    int[][] data = {
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0},
    };
    floodFill(data, new int[] {3, 3}, 2);
    int[][] expected = {
            {0, 0, 0, 1, 2, 2, 2},
            {0, 0, 0, 1, 2, 2, 2},
            {0, 0, 1, 2, 2, 2, 2},
            {1, 1, 2, 2, 2, 1, 1},
            {2, 2, 2, 2, 1, 0, 0},
            {2, 2, 2, 1, 0, 0, 0},
            {2, 2, 2, 1, 0, 0, 0},
    };
    for(int i = 0; i &lt; expected.length; ++i)
    {
        int[] a1 = expected[i];
        int[] a2 = data[i];
        if(!Arrays.equals(a1, a2))
        {
            return false;
        }
    }
    return true;
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="RecursionProblems-GameStrategy">GameStrategy</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1017.0px;"/><col style="width: 594.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>GameStrategy</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Consider a row of n coins of values v1 . . . vn, where n is even.
We play a game against an opponent by alternating turns.
In each turn, a player selects either the first or last coin from the row, removes it from the row permanently,
and receives the value of the coin.
Determine the maximum possible amount of money we can definitely win if we move first.
Examples:
5, 3, 7, 10 : The user collects maximum value as 15(10 + 5)
8, 15, 3, 7 : The user collects maximum value as 22(7 + 15)
Two strategies:
1.  User chooses left coin, opponent chooses left or right
    User collects: Vi + min(F(i+2,j), F(i+1, j-1))
2.  User chooses right coin, opponent chooses left or right
    User collects: Vj + min(F(i+1, j-1), F(i, j-2))
Why:
  If I take Vi, the opponent can choose either Vi+1 or Vj leaving me the choice of:
    If the opponent takes Vi+1, I have a choice of: Vi+2 or Vj
    If the opponent takes Vj, I have a choice of: Vi+1 or Vj-1
  If I take Vj, the opponent can choose wither Vi or Vj-1
    If the opponent takes Vi, I have a choice of: Vi+1 or Vj-1
    If the opponent takes Vj-1, I have a choice of Vi ot Vj-2</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int optimalStrategy(int[] coins)
{
    return optimalStrategy(coins, 0, coins.length - 1);
}

static private int optimalStrategy(int[] coins, int left, int right)
{
    if(left == right)
    {
        return coins[left];
    }
    if(left + 1 == right)
    {
        return Math.max(coins[left], coins[right]);
    }
    int leftMin = Math.min(optimalStrategy(coins, left + 2, right),
            optimalStrategy(coins, left + 1, right - 1));
    int rightMin = Math.min(optimalStrategy(coins, left, right - 2),
            optimalStrategy(coins, left + 1, right - 1));
    return Math.max(coins[left] + leftMin, coins[right] + rightMin);
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check =
            optimalStrategy(new int[] {5, 3, 7, 10}) == 15 &amp;&amp;
            optimalStrategy(new int[] {8, 15, 3, 7}) == 22;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-GenNumberWithSwaps">GenNumberWithSwaps</h2><h3 id="RecursionProblems-maxNumberWithSwaps"><code>maxNumberWithSwaps</code></h3><h3 id="RecursionProblems-minNumberWithSwaps"><code>minNumberWithSwaps</code></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 806.0px;"/><col style="width: 805.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>GenNumberWithSwaps</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Given a positive integer,
find the maximum/minimum integer possible by doing at-most K swap operations on its digits.
Example:                        Example:                    Example:
    Input: M = 254, K = 1           Input: M = 254, K = 2       Input: M = 7599, K = 2
    Output: 524                     Output: 542                 Output: 9975</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int maxNumberWithSwaps(int n, int k)
{
    AtomicInteger max = new AtomicInteger(n);
    maxNumberWithSwaps(String.valueOf(n).toCharArray(), k, max);
    return max.get();
}
private static void maxNumberWithSwaps(char[] a, int k, AtomicInteger max)
{
    if(k == 0)
    {
        return;
    }
    int len = a.length;
    for(int i = 0; i &lt; len - 1; ++i)
    {
        for(int j = i + 1; j &lt; len; ++j)
        {
            if(a[j] &gt; a[i])
            {
                swap(a, i, j);
                int val = Integer.parseInt(new String(a));
                if(val &gt; max.get())
                {
                    max.set(val);
                }
                maxNumberWithSwaps(a, k - 1, max);
                swap(a, i, j);
            }
        }
    }
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int minNumberWithSwaps(int n, int k)
{
    AtomicInteger min = new AtomicInteger(n);
    minNumberWithSwaps(String.valueOf(n).toCharArray(), k, min);
    return min.get();
}
private static void minNumberWithSwaps(char[] a, int k, AtomicInteger min)
{
    if(k == 0)
    {
        return;
    }
    int len = a.length;
    for(int i = 0; i &lt; len - 1; ++i)
    {
        for(int j = i + 1; j &lt; len; ++j)
        {
            if(a[j] &lt; a[i])
            {
                swap(a, i, j);
                int val = Integer.parseInt(new String(a));
                if(val &lt; min.get())
                {
                    min.set(val);
                }
                minNumberWithSwaps(a, k - 1, min);
                swap(a, i, j);
            }
        }
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = maxNumberWithSwaps(543, 1) == 543 &amp;&amp;
            maxNumberWithSwaps(254, 1) == 524 &amp;&amp;
            maxNumberWithSwaps(254, 2) == 542 &amp;&amp;
            maxNumberWithSwaps(7599, 5) == 9975 &amp;&amp;
            maxNumberWithSwaps(12345, 6) == 54321;
    if(!check)
    {
        return false;
    }
    check = minNumberWithSwaps(245, 1) == 245 &amp;&amp;
            minNumberWithSwaps(542, 1) == 245 &amp;&amp;
            minNumberWithSwaps(542, 2) == 245 &amp;&amp;
            minNumberWithSwaps(9957, 5) == 5799 &amp;&amp;
            minNumberWithSwaps(54321, 6) == 12345;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="RecursionProblems-HanoiTower">HanoiTower<br/></h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 912.0px;"/><col style="width: 699.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>HanoiTower</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class HanoiTower
{
    private Stack&lt;Integer&gt; disks = new Stack&lt;&gt;();
    static HanoiTower[] init()
    {
        HanoiTower[] towers = new HanoiTower[3];
        for(int i = 0; i &lt; 3; ++i)
        {
            towers[i] = new HanoiTower();
        }
        for(int i = 2; i &gt;= 0; --i)
        {
            towers[0].disks.push(i);
        }
        return towers;
    }
    private void moveTo(HanoiTower dest)
    {
        dest.disks.push(disks.pop());
    }
    private void moveDisks(int n, HanoiTower dest, HanoiTower buffer)
    {
        if(n &gt; 0)
        {
            moveDisks(n - 1, buffer, dest);
            moveTo(dest);
            buffer.moveDisks(n - 1, dest, this);
        }
    }
    static HanoiTower[] play()
    {
        HanoiTower[] towers = init();
        towers[0].moveDisks(3, towers[1], towers[2]);
        return towers;
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    HanoiTower[] towers = play();
    boolean check = towers[0].disks.size() == 0 &amp;&amp; 
            towers[1].disks.size() == 3 &amp;&amp; towers[2].disks.size() == 0;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-Josephus"><br/>Josephus</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1075.0px;"/><col style="width: 536.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>Josephus</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">There are n people standing in a circle waiting to be executed.
The counting begins at some point in the circle and proceeds around the circle in a fixed direction.
In each step, a certain number of people are skipped and the next person is executed.
The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed),
until only the last person remains, who is given freedom.
Given the total number of persons n and a number k which indicates that k-1 persons are skipped and kth person is killed.
The task is to choose the place in the initial circle so that you are the last one remaining and so survive.</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int josephus(int n, int k)
{
    if(n == 1)
    {
        return 1;
    }
    else
    {
        return (josephus(n - 1, k) + k - 1) % n + 1;
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = josephus(5, 2) == 3;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-KnightTour"><br/>KnightTour</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 923.0px;"/><col style="width: 688.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>KnightTour ( <code>O(8^(SIZE^2))</code> )</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class KnightTour
{
    //  backtracking
    private static int SIZE = 8;
    private static int[][] solution = new int[SIZE][SIZE];
    private static int[] X_MOVES = {2, 1, -1, -2, -2, -1,  1,  2};
    private static int[] Y_MOVES = {1, 2,  2,  1, -1, -2, -2, -1};
    static
    {
        Arrays.stream(solution).forEach(a -&gt; Arrays.fill(a, - 1));
    }

    private static boolean isSafe(int x, int y)
    {
        return x &gt;=0 &amp;&amp; x &lt; solution.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; solution[0].length &amp;&amp; solution[x][y] == -1;
    }

    static boolean solve()
    {
        solution[7][7] = 0;
        return solve(7, 7, 1);
    }

    private static boolean solve(int x, int y, int move)
    {
        if(move == SIZE * SIZE)
        {
            return true;
        }

        for(int i = 0; i &lt; SIZE; ++i)
        {
            int nextX = x + X_MOVES[i];
            int nextY = y + Y_MOVES[i];

            if(isSafe(nextX, nextY))
            {
                solution[nextX][nextY] = move;
                if(solve(nextX, nextY, move + 1))
                {
                    return true;
                }
                solution[nextX][nextY] = -1;
            }
        }
        return false;
    }

    private static void printSolution()
    {
        for(int x = 0; x &lt; solution.length; ++x)
        {
            for(int y = 0; y &lt; solution[0].length; ++y)
            {
                System.out.print(String.format( &quot; %2d &quot;, solution[x][y]));
            }
            System.out.println(&quot;\n&quot;);
        }
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = solve();
    if(!check)
    {
        return false;
    }
    else
    {
        printSolution();
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p /><h2 id="RecursionProblems-LinkedList">LinkedList</h2><h3 id="RecursionProblems-reverse"><code>reverse</code></h3><h3 id="RecursionProblems-nthToLast"><code>nthToLast</code><br/></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 903.0px;"/><col style="width: 708.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>LinkedList</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static&lt;T extends Comparable&lt;T&gt;&gt; List.Node&lt;T&gt; reverse(List.Node&lt;T&gt; head)
{
    if(head == null || head.next == null)
    {
        return head;
    }
    List.Node&lt;T&gt; second = head.next;
    List.Node&lt;T&gt; result = reverse(second);
    head.next = null;
    second.next = head;
    return result;
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static&lt;T extends Comparable&lt;T&gt;&gt; List.Node&lt;T&gt; nthToLast(List.Node&lt;T&gt; head, int k)
{
    return nthToLast(head, k, new IntWrapper());
}


private static class IntWrapper {int value = 0;}


private static&lt;T extends Comparable&lt;T&gt;&gt; List.Node&lt;T&gt; nthToLast(List.Node&lt;T&gt; head, int k, IntWrapper i)
{
    if(head == null)
    {
        return null;
    }
    List.Node&lt;T&gt; priorListNode = nthToLast(head.next, k, i);
    i.value++;
    if(i.value == k)
    {
        return head;
    }
    return priorListNode;
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    List&lt;Integer&gt; list = new List&lt;&gt;();
    list.add(1, 2, 3, 4, 5);
    List.Node&lt;Integer&gt; reversed = reverse(list.head);
    boolean check = reversed.data == 5 &amp;&amp; reversed.next.data == 4 &amp;&amp;
            reversed.next.next.data == 3 &amp;&amp; reversed.next.next.next.data == 2 &amp;&amp;
            reversed.next.next.next.next.data == 1;
    if(!check)
    {
        return false;
    }
    list = new List&lt;&gt;();
    list.add(1, 2, 3, 4, 5, 6, 7);
    List.Node&lt;Integer&gt; n = nthToLast(list.head, 2);
    check = n.data == 6;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>For <code>nthToLast</code>, if <code>k == IntWrapper.value</code>, return <code>head</code>, otherwise returm <code>priorNode</code></p></li></ol><h2 id="RecursionProblems-MakeChange"><br/>MakeChange</h2><h3 id="RecursionProblems-makeChange"><code>makeChange</code></h3><h3 id="RecursionProblems-numberOfWaysToAddUp"><code>numberOfWaysToAddUp</code></h3><h3 id="RecursionProblems-numberOfWaysToAddUpWithPrint"><code>numberOfWaysToAddUpWithPrint</code></h3><h3 id="RecursionProblems-canGetExactChange"><code>canGetExactChange</code></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 903.0px;"/><col style="width: 708.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>MakeChange</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int makeChange(int amount, int denom)
{
    //  Note: assuming 25, 10, 5, 1 denominations
    int nextDenom = 0;
    switch(denom)
    {
        case 25:
            nextDenom = 10;
            break;
        case 10:
            nextDenom = 5;
            break;
        case 5:
            nextDenom = 1;
            break;
        case 1:
            return 1;
    }
    int ways = 0;
    for(int i = 0; i * denom &lt;= amount; ++i)
    {
        ways += makeChange(amount - i * denom, nextDenom);
    }
    return ways;
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int numberOfWaysToAddUp(int amount, int[] denoms)
{
    return numberOfWaysToAddUp(amount, denoms, denoms.length - 1);
}

private static int numberOfWaysToAddUp(int amount, int[] denoms, int lastIndex)
{
    if(amount == 0)
    {
        return 1;
    }
    if(amount &lt; 0 || lastIndex &lt; 0)
    {
        return 0;
    }
    return numberOfWaysToAddUp(amount - denoms[lastIndex], denoms, lastIndex) +
            numberOfWaysToAddUp(amount, denoms, lastIndex - 1);
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static List&lt;int[]&gt; numberOfWaysToAddUpWithPrint(int amount, int[] denoms)
{
    List&lt;int[]&gt; result = new ArrayList&lt;&gt;();
    String s = &quot;&quot;;
    numberOfWaysToAddUpWithPrint(amount, denoms, denoms.length - 1, result, s);
    return result;
}
private static void numberOfWaysToAddUpWithPrint(int amount, int[] denoms,
                                                 int lastIndex, List&lt;int[]&gt; result, String s)
{
    if(amount == 0)
    {
        String[] parts = s.split(&quot;,&quot;);
        int[] vals = Arrays.stream(parts).mapToInt(Integer::valueOf).toArray();
        result.add(vals);
        return;
    }
    if(amount &lt; 0 || lastIndex &lt; 0)
    {
        return;
    }
    numberOfWaysToAddUpWithPrint(amount, denoms, lastIndex - 1, result, s);
    s += denoms[lastIndex] + &quot;,&quot;;
    numberOfWaysToAddUpWithPrint(amount - denoms[lastIndex], denoms, lastIndex, result, s);
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean canGetExactChange(int target, int[] denominations)
{
    return canGetExactChange(target, denominations, denominations.length - 1);
}

private static boolean canGetExactChange(int amount, int[] denominations, int index)
{
    if(amount == 0)
    {
        return true;
    }
    if(amount &lt; 0 || index &lt; 0)
    {
        return false;
    }
    
    return canGetExactChange(amount - denominations[index], denominations, index) ||
            canGetExactChange(amount, denominations, index - 1);
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = makeChange(100, 25) == 242;
    if(!check)
    {
        return false;
    }
    check = numberOfWaysToAddUp(5, new int[] {1, 2, 3}) == 5;
    if(!check)
    {
        return false;
    }
    List&lt;int[]&gt; result = numberOfWaysToAddUpWithPrint(5, new int[] {1, 2, 3});
    check = Arrays.equals(new int[] {1, 1, 1, 1, 1}, result.get(0)) &amp;&amp;
            Arrays.equals(new int[] {2, 1, 1, 1}, result.get(1)) &amp;&amp;
            Arrays.equals(new int[] {2, 2, 1}, result.get(2)) &amp;&amp;
            Arrays.equals(new int[] {3, 1, 1}, result.get(3)) &amp;&amp;
            Arrays.equals(new int[] {3, 2}, result.get(4));
    if(!check)
    {
        return false;
    }
    check = canGetExactChange(94, new int[] {200, 100, 25, 10 , 5});
    if(check)
    {
        return false;
    }
    check = canGetExactChange(75, new int[] {4, 17, 29});
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>Make sure to check both <code>amount </code>and <code>index </code>for <code>&lt; 0</code></p></li><li><p>In <code>numberOfWaysAddUpWithPrint</code> order or recursive calls is important. <code>numberOfWaysAddUpWithPrint(amount, denoms, lastIndex - 1, result, s)</code> must be called BEFORE <code>numberOfWaysAddUpWithPrint(amount - denoms[index], denoms, lastIndex, result, s)</code></p></li></ol><h2 id="RecursionProblems-Maze"><br/>Maze</h2><p>See also <a href="https://nickguner.atlassian.net/wiki/spaces/DEV/pages/875528209/Fifo-Lifo+Problems#Maze%5BhardBreak%5D" data-card-appearance="inline" rel="nofollow">https://nickguner.atlassian.net/wiki/spaces/DEV/pages/875528209/Fifo-Lifo+Problems#Maze%5BhardBreak%5D</a> </p><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 875.0px;"/><col style="width: 736.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>Maze</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class Maze
{
    //  backtracking
    static int[][] solve(int[][] maze)
    {
        int [][] solution = new int[maze.length][maze[0].length];

        solve(0, 0, maze, solution);
        return solution;
    }

    private static boolean solve(int x, int y, int[][] maze, int[][] solution)
    {
        if(x == maze.length - 1 &amp;&amp; y == maze[0].length - 1)
        {
            solution[x][y] = 1;
            return true;
        }

        if(isValid(maze, x, y))
        {
            solution[x][y] = 1;
            if(solve(x + 1, y, maze, solution))
            {
                return true;
            }
            if(solve(x, y + 1, maze, solution))
            {
                return true;
            }
            solution[x][y] = 0;
        }
        return false;
    }

    private static boolean isValid(int[][] maze, int x, int y)
    {
        return x &gt;= 0 &amp;&amp; x &lt; maze.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; maze[0].length &amp;&amp; maze[x][y] == 1;
    }


    private static void printSolution(int[][] solution)
    {
        for(int x = 0; x &lt; solution.length; ++x)
        {
            for(int y = 0; y &lt; solution[0].length; ++y)
            {
                System.out.print(String.format( &quot; %2d &quot;, solution[x][y]));
            }
            System.out.println(&quot;\n&quot;);
        }
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    int[][] data = new int [][] {
            {1, 1, 0, 1},
            {0, 1, 0, 0},
            {0, 1, 1, 0},
            {0, 0, 1, 1},
            {0, 0, 0, 1}
    };
    int[][] solution = solve(data);
    boolean check = solution[solution.length - 1][solution[0].length - 1] == 1;
    if(!check)
    {
        return false;
    }
    check = Arrays.equals(new int[] {1, 1, 0, 0}, solution[0]) &amp;&amp;
            Arrays.equals(new int[] {0, 1, 0, 0}, solution[1]) &amp;&amp;
            Arrays.equals(new int[] {0, 1, 1, 0}, solution[2]) &amp;&amp;
            Arrays.equals(new int[] {0, 0, 1, 1}, solution[3]) &amp;&amp;
            Arrays.equals(new int[] {0, 0, 0, 1}, solution[4]);
    if(!check)
    {
        return false;
    }
    printSolution(solution);
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-NSumOrProduct">NSumOrProduct</h2><h3 id="RecursionProblems-generateNSum"><code>generateNSum</code></h3><h3 id="RecursionProblems-generateNProduct"><code>generateNProduct</code><br/></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>NSum</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Find all subsets in array that add up to some number
[1, 3, 4, 5, 6, 8, 15]
15 = 1+3+5+6
15 = 1+6+8
15 = 3+4+8
15 = 4+5+6
15 = 15</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static List&lt;int[]&gt; generateNSum(int target, int[] vals)
{
    Arrays.sort(vals);
    List&lt;int[]&gt; result = new ArrayList&lt;&gt;();
    generate(target, vals, 0, 0, new Stack&lt;&gt;(), result);
    return result;
}

private static void generateNSum(int target, int[] sortedVals,
                                    int index, int sumOnStack, Stack&lt;Integer&gt; stack,
                                    List&lt;int[]&gt; result)
{
    if(sumOnStack == target)
    {
        result.add(stack.stream().mapToInt(x -&gt; x).toArray());
        return;
    }
    for(int i = index; i &lt; sortedVals.length; ++i)
    {
        if(sortedVals[i] + sumOnStack &lt;= target)
        {
            stack.push(sortedVals[i]);
            sumOnStack += sortedVals[i];
            generate(target, sortedVals, i + 1, sumOnStack, stack, result);
            sumOnStack -= stack.pop();
        }
    }
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">//  16 has factors:
//  2, 2, 2, 2
//  2, 2, 4
//  2, 8
//  4, 4</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static List&lt;int[]&gt; generateNProduct(int target)
{
    List&lt;int[]&gt; result = new ArrayList&lt;&gt;();
    generateNProduct(target, 2, 1, new Stack&lt;&gt;(), result);
    return result;
}

private static void generateNProduct(int target, int startVal, int currentProduct,
                                     Stack&lt;Integer&gt; stack, List&lt;int[]&gt; result)
{
    if(currentProduct &gt; target || startVal &gt; target)
    {
        return;
    }
    if(currentProduct == target)
    {
        result.add(stack.stream().mapToInt(x -&gt; x).toArray());
        return;
    }
    for(int i = startVal; i &lt; target; ++i)
    {
        if(i * currentProduct &lt;= target &amp;&amp; target % i == 0)
        {
            stack.push(i);
            generateNProduct(target, i, i * currentProduct, stack, result);
            stack.pop();
        }
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    List&lt;int[]&gt; result = generateNSum(15, new int[] {6, 1, 8, 5, 3, 15, 4});
    boolean check = result.size() == 5;
    if(!check)
    {
        return false;
    }
    check = Arrays.equals(new int[] {1, 3, 5, 6}, result.get(0)) &amp;&amp;
            Arrays.equals(new int[] {1, 6, 8}, result.get(1)) &amp;&amp;
            Arrays.equals(new int[] {3, 4, 8}, result.get(2)) &amp;&amp;
            Arrays.equals(new int[] {4, 5, 6}, result.get(3)) &amp;&amp;
            Arrays.equals(new int[] {15}, result.get(4));
    if(!check)
    {
        return false;
    }
    result = generateNProduct(16);
    check = Arrays.equals(new int[] {2, 2, 2, 2}, result.get(0)) &amp;&amp;
            Arrays.equals(new int[] {2, 2, 4}, result.get(1)) &amp;&amp;
            Arrays.equals(new int[] {2, 8}, result.get(2)) &amp;&amp;
            Arrays.equals(new int[] {4, 4}, result.get(3));
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>array of <code>vals </code>passed to recursive function must be sorted</p></li><li><p>Use <code>Stack, sumOnStack, index</code> variables</p></li><li><p><code>for </code>loop starts from <code>index</code> to the length of <code>vals </code>array</p></li><li><p>Recursively call <code>generate </code>with <code>i + 1</code>, not<code> index + i</code></p></li><li><p>Decrement <code>sumOnStack </code>and pop the stack after call to recursive function</p></li></ol><h2 id="RecursionProblems-NumericOperations"><br/>NumericOperations</h2><h3 id="RecursionProblems-gcd"><code>gcd</code></h3><h3 id="RecursionProblems-add"><code>add</code></h3><h3 id="RecursionProblems-multiply"><code>multiply</code></h3><h3 id="RecursionProblems-exponent"><code>exponent</code></h3><h3 id="RecursionProblems-toBinary"><code>toBinary</code></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>NumericOperations</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static int gcd(int a, int b)
{
    if(b == 0)
    {
        return a;
    }
    return gcd(b, a % b);
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int add(int a, int b)
{
    if(b == 0)
    {
        return a;
    }
    int sum = a ^ b;
    int carry = (a &amp; b) &lt;&lt; 1;
    return add(sum, carry);
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int multiply(int a, int b)
{
    if(b == 0) return 0;
    if(b % 2 == 0)
    {
        return multiply(a + a, b / 2);
    }
    else
    {
        return multiply(a + a, b / 2) + a;
    }
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int exponent(int a, int b)
{
    if(b == 0)
    {
        return 1;
    }
    if(b % 2 == 0)
    {
        return exponent(a * a, b / 2);
    }
    else
    {
        return exponent(a * a, b / 2) * a;
    }
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static String toBinary(int n, StringBuilder sb)
{
    if(n == 0)
    {
        return &quot;&quot;;
    }
    toBinary(n / 2, sb);
    sb.append(n % 2);
    return sb.toString();
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = gcd(8, 36) == 4;
    if(!check)
    {
        return false;
    }
    check = add(159, 37) == 196;
    if(!check)
    {
        return false;
    }
    check = multiply(12, 19) == 228;
    if(!check)
    {
        return false;
    }
    check = exponent(2, 10) == 1024;
    if(!check)
    {
        return false;
    }
    check = toBinary(55, new StringBuilder()).equals(&quot;110111&quot;);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-Palindrome"><br/>Palindrome</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>Palindrome</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean stringPalindrome(String s)
{
    if(s.length() &lt; 2)
    {
        return true;
    }
    if(s.charAt(0) != s.charAt(s.length() - 1))
    {
        return false;
    }
    return stringPalindrome(s.substring(1, s.length() - 1));
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    String s1 = &quot;abcddcba&quot;, s2 = &quot;abcdcba&quot;, s3 = &quot;abcdba&quot;;
    boolean check = stringPalindrome(s1) &amp;&amp; stringPalindrome(s2) &amp;&amp; !stringPalindrome(s3);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="RecursionProblems-PhoneNumbers">PhoneNumbers</h2><h3 id="RecursionProblems-countPhoneCombinationsWithKnight"><code>countPhoneCombinationsWithKnight</code></h3><h3 id="RecursionProblems-keepPhoneNumbersWithKnight"><code>keepPhoneNumbersWithKnight</code><br/></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 879.0px;"/><col style="width: 732.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>PhoneNumbers</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int[][] MOVES = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{1,7,0},{2,6},{1,3},{2,4}};</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int countPhoneCombinationsWithKnight(int numDigits, int currentNum, int move)
{
    if(move == numDigits)
    {
        return 1;
    }
    int count = 0;
    int[] currentMoves = MOVES[currentNum];
    for(int i = 0; i &lt; currentMoves.length; ++i)
    {
        count += countPhoneCombinationsWithKnight(numDigits, currentMoves[i], move + 1);
    }
    return count;
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static List&lt;String&gt; keepPhoneNumbersWithKnight(int numDigits, int currentNum, int move)
{
    List&lt;String&gt; result = new ArrayList&lt;&gt;();
    keepPhoneNumbersWithKnight(numDigits, currentNum, move, result, new StringBuilder());
    return result;
}
private static void keepPhoneNumbersWithKnight(int numDigits, int currentNum,
                                               int move, List&lt;String&gt; result, StringBuilder sb)
{
    if(move == numDigits)
    {
        result.add(sb.toString());
        return;
    }
    int[] currentMoves = MOVES[currentNum];
    for(int i = 0; i &lt; currentMoves.length; ++i)
    {
        sb.delete(move, sb.length());
        sb.append(currentMoves[i]);
        keepPhoneNumbersWithKnight(numDigits, currentMoves[i], move + 1, result, sb);
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = countPhoneNumbersWithKnight(10,0, 0) == 4608;
    if(!check)
    {
        return false;
    }
    check = countPhoneNumbersWithKnight(2,0, 0) == 6;
    if(!check)
    {
        return false;
    }
    List&lt;String&gt; result = keepPhoneNumbersWithKnight(2, 0, 0);
    check = result.size() == 6;
    if(!check)
    {
        return false;
    }
    check = result.get(0).equals(&quot;40&quot;) &amp;&amp; result.get(1).equals(&quot;43&quot;) &amp;&amp; result.get(2).equals(&quot;49&quot;)
            &amp;&amp; result.get(3).equals(&quot;61&quot;) &amp;&amp; result.get(4).equals(&quot;67&quot;) &amp;&amp; result.get(5).equals(&quot;60&quot;);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-PlaceQueens">PlaceQueens<br/></h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>PlaceQueens</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class PlaceQueens
{
    //  backtracking
    private static int SIZE = 8;
    private static int[][] solution = new int[SIZE][SIZE];

    static boolean solve()
    {
        return solve(0);
    }

    static private boolean solve(int col)
    {
        if(col == SIZE)
        {
            return true;
        }
        for(int row = 0; row &lt; SIZE; ++row)
        {
            if(isSafe(row, col))
            {
                solution[row][col] = 1;
                if(solve(col + 1))
                {
                    return true;
                }
                solution[row][col] = 0;
            }
        }
        return false;
    }

    private static boolean isSafe(int row, int col)
    {
        for(int i = 0; i &lt; SIZE; ++i)
        {
            if (solution[row][i] == 1)
            {
                return false;
            }
            if (solution[i][col] == 1)
            {
                return false;
            }
            for (int j = 0; j &lt;SIZE; ++j)
            {
                if (solution[i][j] == 1 &amp;&amp; Math.abs(row - i) == Math.abs(col - j))
                {
                    return false;
                }
            }
        }
        return true;
    }

    private static void printSolution()
    {
        for(int x = 0; x &lt; SIZE; ++x)
        {
            for(int y = 0; y &lt; SIZE; ++y)
            {
                System.out.print(String.format( &quot; %2d &quot;, solution[x][y]));
            }
            System.out.println(&quot;\n&quot;);
        }
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static void main(String[] args)
{
    if(solve())
    {
        printSolution();
    }
    else
    {
        System.out.println(&quot;Solution does not exist&quot;);
    }
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><ol><li><p>Use <code>row </code>&amp; <code>col </code>parameter names to <code>isSafe </code>method (instead of <code>x</code> &amp; <code>y</code>)</p></li><li><p>Method <code>solve </code>only needs one loop since <code>col </code>parameter is passed in</p></li><li><p>To check diagonals use: <code>if(solution[i][j] == 1 &amp;&amp; Math.abs(row - i) == Math.abs(col - j))</code></p></li><li><p>In <code>Math.abs</code>, note use of two loop variables <code>i</code> (for row) and <code>j</code> (for col) in checking diagonals</p></li></ol><h2 id="RecursionProblems-PowerSet">PowerSet<br/></h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>PowerSet</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static List&lt;List&lt;Character&gt;&gt; generate(String s)
{
    List&lt;Character&gt; chars = s.chars().mapToObj(c -&gt; (char)c).collect(Collectors.toList());
    return generate(chars);
}

private static List&lt;List&lt;Character&gt;&gt; generate(List&lt;Character&gt; input)
{
    List&lt;List&lt;Character&gt;&gt; result = new ArrayList&lt;&gt;();
    if(input.isEmpty())
    {
        result.add(new ArrayList&lt;&gt;());
        return result;
    }
    Character first = input.get(0);
    List&lt;Character&gt; rem = input.subList(1, input.size());
    for(List&lt;Character&gt; sub : generate(rem))
    {
        List&lt;Character&gt; list = new ArrayList&lt;&gt;();
        list.add(first);
        list.addAll(sub);
        
        result.add(list);
        result.add(sub);
    }
    return result;
}</pre>
</div></div><p><br/></p></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    List&lt;List&lt;Character&gt;&gt; result = generate(&quot;ABC&quot;);
    boolean check = result.size() == 8;
    if(!check)
    {
        return false;
    }
    char[] a = result.get(0).stream().map(Object::toString).collect(Collectors.joining()).toCharArray();
    check = Arrays.equals(new char[] {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}, a);
    if(!check)
    {
        return false;
    }
    a = result.get(1).stream().map(Object::toString).collect(Collectors.joining()).toCharArray();
    check = Arrays.equals(new char[] {&#39;B&#39;, &#39;C&#39;}, a);
    if(!check)
    {
        return false;
    }
    a = result.get(2).stream().map(Object::toString).collect(Collectors.joining()).toCharArray();
    check = Arrays.equals(new char[] {&#39;A&#39;, &#39;C&#39;}, a);
    if(!check)
    {
        return false;
    }
    a = result.get(3).stream().map(Object::toString).collect(Collectors.joining()).toCharArray();
    check = Arrays.equals(new char[] {&#39;C&#39;}, a);
    if(!check)
    {
        return false;
    }
    a = result.get(4).stream().map(Object::toString).collect(Collectors.joining()).toCharArray();
    check = Arrays.equals(new char[] {&#39;A&#39;, &#39;B&#39;}, a);
    if(!check)
    {
        return false;
    }
    a = result.get(5).stream().map(Object::toString).collect(Collectors.joining()).toCharArray();
    check = Arrays.equals(new char[] {&#39;B&#39;}, a);
    if(!check)
    {
        return false;
    }
    a = result.get(6).stream().map(Object::toString).collect(Collectors.joining()).toCharArray();
    check = Arrays.equals(new char[] {&#39;A&#39;}, a);
    if(!check)
    {
        return false;
    }
    a = result.get(7).stream().map(Object::toString).collect(Collectors.joining()).toCharArray();
    check = Arrays.equals(new char[0], a);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>If <code>input </code>is empty, add <code>ArrayList&lt;&gt;()</code> to <code>result </code>and return the <code>result</code></p></li><li><p>Inside foreach, create new List and add <code>first </code>and <code>sub </code>to it</p></li><li><p>Add new <code>list </code>and <code>sub </code>to <code>result</code></p></li><li><p>Complexity: <code>O(2^n * n)</code></p></li></ol><h2 id="RecursionProblems-RemoveAdjacentDups">RemoveAdjacentDups<br/></h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>RemoveAdjacentDups</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static String removeAdjacentDups(String s)
{
    if(s.length() == 1)
    {
        return s;
    }
    if(s.charAt(0) == s.charAt(1))
    {
        return removeAdjacentDups(s.substring(1));
    }
    else
    {
        return s.charAt(0) + removeAdjacentDups(s.substring(1));
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = removeAdjacentDups(&quot;aaabbbbcccb&quot;).equals(&quot;abcb&quot;);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-ReverseStack">ReverseStack</h2><h3 id="RecursionProblems-reverse.1"><code>reverse</code></h3><h3 id="RecursionProblems-insertAtBottom"><code>insertAtBottom</code><br/></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>ReverseStack</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static&lt;T&gt; void reverse(Stack&lt;T&gt; s)
{
    if(!s.isEmpty())
    {
        T t = s.pop();
        reverse(s);
        insertAtBottom(s, t);
    }
}


private static&lt;T&gt; void insertAtBottom(Stack&lt;T&gt; s, T val)
{
    if(s.isEmpty())
    {
        s.push(val);
    }
    else
    {
        T temp = s.pop();
        insertAtBottom(s, val);
        s.push(temp);
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
    s.push(5); s.push(4); s.push(3); s.push(2); s.push(1);
    reverse(s);
    int[] a = s.stream().mapToInt(x -&gt; x).toArray();
    boolean check = Arrays.equals(new int[] {1, 2, 3, 4, 5}, a);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-RodCutting"><br/>RodCutting</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>RodCutting</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Consider a rod which can be cut into multiple pieces and corresponding price for each piece.
    For example:
        Rod is 4 ft long with following prices
        Length: 1 2 3 4
        Price:  2 4 8 9
    Compute max amount that could be made from cutting/or  not curring this rod
      Lengths     Price
      -----------------
      4               9
      1,1,1,1         8
      2,2             8
      1,3             10</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int maxValue(int[] prices)
{
    return maxValue(prices, prices.length);
}


private static int maxValue(int[] prices, int n)
{
    if(n == 0)
    {
        return 0;
    }
    int max = Integer.MIN_VALUE;
    for(int i = 0; i &lt; n; ++i)
    {
        max = Math.max(max, prices[i] + maxValue(prices, n - i - 1));
    }
    return max;
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = maxValue(new int[] {2, 4, 8, 9}) == 10;
    if(!check)
    {
        return false;
    }
    check = maxValue(new int[] {2, 4, 8, 11}) == 11;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>Use second parameter <code>n</code> (<code>prices.length</code>) to check base case and condition variable in the <code>for </code>loop</p></li></ol><h2 id="RecursionProblems-StairWalk">StairWalk</h2><h3 id="RecursionProblems-countWays"><code>countWays</code></h3><h3 id="RecursionProblems-countWaysWithMemoization"><code>countWaysWithMemoization</code></h3><h4 id="RecursionProblems-SeealsoFibonacci">See also <a href="https://nickguner.atlassian.net/wiki/spaces/DEV/pages/875528233/Recursion+Problems#Fibonacci" rel="nofollow">Fibonacci</a><br/></h4><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>StairWalk</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int countWays(int stairs)
{
    if(stairs &lt; 0) return 0;
    if(stairs == 0) return  1;
    return countWays(stairs - 1) + 
            countWays(stairs - 2) + 
            countWays(stairs - 3);
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static int countWaysWithMemoization(int stairs)
{
    if(stairs &lt; 0)
    {
        return 0;
    }
    if(stairs &lt; 2)
    {
        return 1;
    }
    if(stairs == 2)
    {
        return 2;
    }
    int[] dp = new int[stairs + 1];
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;
    return countWaysWithMemoization(stairs, dp);
}
private static int countWaysWithMemoization(int n, int[] dp)
{
    if(dp[n] == 0)
    {
        dp[n] = countWaysWithMemoization(n - 1, dp) +
                countWaysWithMemoization(n - 2, dp) +
                countWaysWithMemoization(n - 3, dp);
    }
    return dp[n];
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = countWays(0) == 1;
    if(!check)
    {
        return false;
    }
    check = countWays(1) == 1;
    if(!check)
    {
        return false;
    }
    check = countWays(2) == 2;
    if(!check)
    {
        return false;
    }
    check = countWays(3) == 4;
    if(!check)
    {
        return false;
    }
    check = countWays(10) == 274;
    if(!check)
    {
        return false;
    }
    check = countWaysWithMemoization(0) == 1;
    if(!check)
    {
        return false;
    }
    check = countWaysWithMemoization(1) == 1;
    if(!check)
    {
        return false;
    }
    check = countWaysWithMemoization(2) == 2;
    if(!check)
    {
        return false;
    }
    check = countWaysWithMemoization(3) == 4;
    if(!check)
    {
        return false;
    }
    check = countWaysWithMemoization(10) == 274;
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>For memoization, public function creates <code>dp </code>array and sets it with initial values, recursive function checks base cases and sets <code>dp[n]</code> if it was equal to 0.</p></li><li><p>Recursive <code>countWaysWithMemoization</code> checks <code>dp[n] == 0 </code>and returns <code>dp[n]</code></p></li></ol><h2 id="RecursionProblems-StringPermutations"><br/>StringPermutations</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>StringPermutations</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static List&lt;String&gt; stringPermutations(String s)
{
    List&lt;String&gt; result = new ArrayList&lt;&gt;();
    if(s.length() &gt; 1)
    {
        char firstChar = s.charAt(0);
        String rem = s.substring(1);
        for(String word : stringPermutations(rem))
        {
            for(int i = 0; i &lt;= word.length(); ++i)
            {
                String p = insertAtChar(word, firstChar, i);
                result.add(p);
            }
        }
    }
    else
    {
        result.add(s);
    }
    return result;
}


private static String insertAtChar(String s, char c, int i)
{
    String start = s.substring(0, i);
    String end = s.substring(i);
    return start + c + end;
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    String test = &quot;ABC&quot;;
    List&lt;String&gt; perms = stringPermutations(test);
    boolean check = perms.size() == 6;
    if(!check)
    {
        return false;
    }
    check = perms.contains(&quot;ABC&quot;) &amp;&amp; perms.contains(&quot;ACB&quot;) &amp;&amp; perms.contains(&quot;BAC&quot;) &amp;&amp;
            perms.contains(&quot;BCA&quot;) &amp;&amp; perms.contains(&quot;CAB&quot;) &amp;&amp; perms.contains(&quot;CBA&quot;);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><h2 id="RecursionProblems-StringWildMatch"><br/>StringWildMatch</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>StringWildMatch</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean wildMatch(String s, String pattern)
{
    while(pattern.length() &gt; 0)
    {
        if(pattern.charAt(0) == &#39;?&#39;)
        {
            if(s.length() == 0)
            {
                return false;
            }
            s = s.substring(1);
            pattern = pattern.substring(1);
        }
        else if(pattern.charAt(0) == &#39;*&#39;)
        {
            if(wildMatch(s, pattern.substring(1)))
            {
                return true;
            }
            if(s.length() &gt; 0 &amp;&amp; wildMatch(s.substring(1), pattern))
            {
                return true;
            }
            return false;
        }
        else
        {
            if(s.length() == 0 || s.charAt(0) != pattern.charAt(0))
            {
                return false;
            }
            s = s.substring(1);
            pattern = pattern.substring(1);
        }
    }
    return s.length() == pattern.length();
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    boolean check = wildMatch(&quot;Good Morning&quot;, &quot;*d*&quot;);
    if(!check)
    {
        return false;
    }
    check = wildMatch(&quot;Good Morning&quot;, &quot;*ing&quot;);
    if(!check)
    {
        return false;
    }
    check = wildMatch(&quot;Good Morning&quot;, &quot;Goo*ing&quot;);
    if(!check)
    {
        return false;
    }
    check = !wildMatch(&quot;Good Morning&quot;, &quot;Good *x&quot;);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>For checks against '*' make sure to return <code>false </code>as last statement in the <code>if </code>block</p></li></ol><h2 id="RecursionProblems-Subsequence"><br/>Subsequence</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 969.0px;"/><col style="width: 642.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>Subsequence</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static String longestSubsequence(String s1, String s2)
{
    return longestSubsequence(s1.toCharArray(), s2.toCharArray(), s1.length(), s2.length());
}


static private String longestSubsequence(char[] a1, char[] a2, int len1, int len2)
{
    if(len1 == 0 || len2 == 0)
    {
        return &quot;&quot;;
    }
    if(a1[len1 - 1] == a2[len2 - 1])
    {
        return longestSubsequence(a1, a2, len1 - 1, len2 - 1) + a1[len1 - 1];
    }
    else
    {
        String s1 = longestSubsequence(a1, a2, len1 - 1, len2);
        String s2 = longestSubsequence(a1, a2, len1, len2 - 1);
        return s1.length() &gt; s2.length() ? s1 : s2;
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    String s1 = &quot;abcdefg&quot;, s2 = &quot;acefxyz&quot;;
    boolean check = longestSubsequence(s1, s2).equals(&quot;acef&quot;);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>Base case when either len1 or len2 is 0</p></li></ol><h2 id="RecursionProblems-Sudoku">Sudoku</h2><h3 id="RecursionProblems-solve"><code>solve</code></h3><h3 id="RecursionProblems-isValid"><code>isValid</code><br/></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 816.0px;"/><col style="width: 795.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>Sudoku</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class Sudoku
{
    //  backtracking
    private static Integer[][] board;
    public Sudoku(Integer[][] board)
    {
        this.board = board;
    }

    boolean solve()
    {
        for(int row = 0; row &lt; 9; ++row)
        {
            for(int col = 0; col &lt; 9; ++col)
            {
                if(board[row][col] != null)
                {
                    continue;
                }

                for(Integer val = 1; val &lt;= 9; ++val)
                {
                    if(isValid(row, col, val))
                    {
                        board[row][col] = val;
                        if(solve())
                        {
                            return true;
                        }
                        board[row][col] = null;
                    }
                }
                return false;
            }
        }
        return true;
    }

    boolean isValid(int row, int col, Integer val)
    {
        for(int i = 0; i &lt; 9; ++i)
        {
            if(board[i][col] != null &amp;&amp; board[i][col] == val)
            {
                return false;
            }
            if(board[row][i] != null &amp;&amp; board[row][i] == val)
            {
                return false;
            }

            int boxRowIdx = 3 * (row / 3) + i / 3;
            int boxColIdx = 3 * (col / 3) + i % 3;
            if(board[boxRowIdx][boxColIdx] != null &amp;&amp; board[boxRowIdx][boxColIdx] == val)
            {
                return false;
            }
        }
        return true;
    }

    private static void printSolution()
    {
        for(int i = 0; i &lt; board.length; ++i)
        {
            for(int j = 0; j &lt; board[0].length; ++j)
            {
                System.out.print(String.format(&quot; %2d &quot;, board[i][j]));
            }
            System.out.println(&quot;\n&quot;);
        }
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static void main(String[] args)
{
    Integer[][] board = new Integer[][] {
            {   5,    3, null, null,    7, null, null, null, null},
            {   6, null, null,    1,    9,    5, null, null, null},
            {null,    9,    8, null, null, null, null,    6, null},
            {   8, null, null, null,    6, null, null, null,    3},
            {   4, null, null,    8, null,    3, null, null,    1},
            {   7, null, null, null,    2, null, null, null,    6},
            {null,    6, null, null, null, null,    2,    8, null},
            {null, null, null,    4,    1,    9, null, null,    5},
            {null, null, null, null,    8, null, null,    7,    9}
    };
    Sudoku sudoku = new Sudoku(board);
    if(sudoku.solve())
    {
        printSolution();
    }
    else
    {
        System.out.println(&quot;Solution does not exist.&quot;);
    }
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p><code>isValid </code>only needs a single for loop</p></li><li><p>recursive <code>solve </code>function uses three loops: <code>row, col, val</code></p></li><li><p>In <code>solve</code>, return: <code>true, false, true</code></p></li><li><p>To check boxes in <code>isValid </code>use  <code> rowBoxIdx = 3 * (row / 3) + i / 3</code>, <code>colBoxIdx = 3 * (col / 3) + i % 3;</code></p></li></ol><h2 id="RecursionProblems-TravellingSalesman"><br/>TravellingSalesman</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 812.0px;"/><col style="width: 799.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>TravellingSalesman</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class TravellingSalesman
{
/*
    Let&#39;s consider 4 points: A, B, C, D
    Distances between these points may be represented by a 2-D array:
             A   B   C   D
        A:  {0, 20, 42, 25}
        B:  {20, 0, 30, 34}
        C:  {42, 30, 0, 10}
        D:  {25, 34, 10, 0}
    Thus:
        A -&gt; B = 20, A -&gt; C = 42, A -&gt; D = 25
        B -&gt; A = 20, B -&gt; C = 30, B -&gt; D = 34
        C -&gt; A = 42, C -&gt; B = 30, C -&gt; D = 10
        D -&gt; A = 25, D -&gt; B = 34, D -&gt; C = 10
 */

    static int VISITED_ALL;
    static int[][] MATRIX;

    static int tsp(int[][] martix)
    {
        VISITED_ALL = (1 &lt;&lt; martix.length) - 1;
        MATRIX = martix;
        return tsp(1, 0);
    }

    private static int tsp(int mask, int pos)
    {
        if(mask == VISITED_ALL)
        {
            return MATRIX[pos][0];
        }

        int min = Integer.MAX_VALUE;
        for(int city = 0; city &lt; MATRIX.length; ++city)
        {
            if((mask &amp; (1 &lt;&lt; city)) == 0)   // city not yet visited
            {
                int ans = MATRIX[pos][city] + tsp(mask | (1 &lt;&lt; city), city);
                min = Math.min(min, ans);
            }
        }
        return min;
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    int[][] data1 = {
            {0, 20, 42, 25},
            {20, 0, 30, 34},
            {42, 30, 0, 10},
            {25, 34, 10, 0}
    };
    boolean check = tsp(data1) == 85;
    if(!check)
    {
        return false;
    }
    int[][] data2 = {
            {0, 12, 10, 19,  8},
            {12, 0,  3,  7,  2},
            {10, 3,  0,  6, 20},
            {19, 7,  6,  0,  4},
            { 8, 2, 20,  4,  0},
    };
    check = tsp(data2) == 32;
    if(!check)
    {
        return false;
    }
    int[][] data3 = {
            {0, 29, 82, 46, 68, 52, 72, 42},
            {29, 0, 55, 46, 42, 43, 43, 23},
            {82, 55, 0, 68, 46, 55, 23, 43},
            {46, 46, 68, 0, 82, 15, 72, 31},
            {68, 42, 46, 82, 0, 74, 23, 52},
            {52, 43, 55, 15, 74, 0, 61, 23},
            {72, 43, 23, 72, 23, 61, 0, 42},
            {42, 23, 43, 31, 52, 23, 42, 0}
    };
    check = tsp(data3) == 244;
    if(!check)
    {
        return false;
    }
    
    return true;
}</pre>
</div></div></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>Call recursive function with mask of 1, not 0</p></li><li><p>Loop variable <code>city</code> (in <code>for(int city = 0, )</code>) must always be in the second dimenstion</p></li><li><p>Check and modify mask with <code>city </code>variable (<code>(mask &amp; (1 &lt;&lt; city)) == 0</code>, <code>mask | (1 &lt;&lt; city)</code></p></li><li><p>Use <code>pos </code>as first dimension to MARTIX (<code>MATRIX[pos][city]</code>)</p></li></ol><h2 id="RecursionProblems-ValidParens"><br/>ValidParens</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1046.0px;"/><col style="width: 565.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>ValidParens</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static List&lt;String&gt; generateValidParens(int count)
{
    char[] buffer = new char[count * 2];
    List&lt;String&gt; result = new ArrayList&lt;&gt;();
    generateValidParens(result, count, count, 0 , buffer);
    return result;
}
static private void generateValidParens(List&lt;String&gt; result, 
                                        int leftRem, int rightRem, 
                                        int idx, char[] buffer)
{
    if(leftRem &lt; 0 || rightRem &lt; leftRem)
    {
        return;
    }
    if(leftRem == 0 &amp;&amp; rightRem == 0)
    {
        result.add(new String(buffer));
        return;
    }
    if(leftRem &gt; 0)
    {
        buffer[idx] = &#39;(&#39;;
        generateValidParens(result, leftRem -1, rightRem, idx + 1, buffer);
    }
    if(rightRem &gt; 0)
    {
        buffer[idx] = &#39;)&#39;;
        generateValidParens(result, leftRem, rightRem - 1, idx + 1, buffer);
    }
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    List&lt;String&gt; result = generateValidParens(3);
    boolean check =
            result.get(0).equals(&quot;((()))&quot;) &amp;&amp;
            result.get(1).equals(&quot;(()())&quot;) &amp;&amp;
            result.get(2).equals(&quot;(())()&quot;) &amp;&amp;
            result.get(3).equals(&quot;()(())&quot;) &amp;&amp;
            result.get(4).equals(&quot;()()()&quot;);
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div><p><br/></p></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>set size of <code>char </code>buffer to <code>2 * count</code><br/></p></li></ol><h2 id="RecursionProblems-WordBreak">WordBreak</h2><h3 id="RecursionProblems-wordBreak"><code>wordBreak</code></h3><h3 id="RecursionProblems-wordBreakWithMemoization"><code>wordBreakWithMemoization</code></h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 875.0px;"/><col style="width: 736.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p>WordBreak</p></th><th class="confluenceTh"><p>Tests</p></th></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">sstatic Map&lt;String,List&lt;String&gt;&gt; wordBreak(List&lt;String&gt; input)
{
    Set&lt;String&gt; dictionary = new HashSet&lt;&gt;(input);
    Map&lt;String,List&lt;String&gt;&gt; result = new HashMap&lt;&gt;();
    for(String word : input)
    {
        List&lt;String&gt; bufferResult = new ArrayList&lt;&gt;();
        wordBreak(dictionary, word, &quot;&quot;, bufferResult);
        int size = bufferResult.size();
        if(size &gt; 1)
        {
            String key = bufferResult.get(size - 1);
            List&lt;String&gt; list = bufferResult.stream()
                    .limit(size - 1)
                    .collect(Collectors.toList());
            result.put(key, list);
        }
    }
    return result;
}

private static void wordBreak(Set&lt;String&gt; dictionary, String word, 
                              String buffer, List&lt;String&gt; bufferResult)
{
    if(word.length() == 0)
    {
        bufferResult.add(buffer.trim());
        return;
    }
    for(int i = 1; i &lt;= word.length(); i++)
    {
        String prefix = word.substring(0, i);
        if (dictionary.contains(prefix))
        {
            wordBreak(dictionary, word.substring(i), buffer + &quot; &quot; + prefix, bufferResult);
        }
    }
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean wordBreak(Set&lt;String&gt; dictionary, String word)
{
    if(word.length() == 0)
    {
        return true;
    }
    for(int i = 1; i &lt;= word.length(); ++i)
    {
        String prefix = word.substring(0, i);
        if(dictionary.contains(prefix) &amp;&amp; wordBreak(dictionary, word.substring(i)))
        {
            return true;
        }
    }
    return false;
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean wordBreakWithMemoization(Set&lt;String&gt; dictionary, String word, 
                                                              Map&lt;String, Boolean&gt; memoMap)
{
    if(word.length() == 0)
    {
        return true;
    }
    if(memoMap.containsKey(word))
    {
        return memoMap.get(word);
    }
    for(int i = 1; i &lt;= word.length(); ++i)
    {
        String prefix = word.substring(0, i);
        if(dictionary.contains(prefix) &amp;&amp; wordBreak(dictionary, word.substring(i)))
        {
            memoMap.put(word, true);
            return true;
        }
    }
    memoMap.put(word, false);
    return false;
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static boolean testsPass()
{
    List&lt;String&gt; data = Arrays.asList(&quot;rockstar&quot;, &quot;star&quot;, &quot;rock&quot;, &quot;rocks&quot;,
            &quot;tar&quot;, &quot;stars&quot;, &quot;rockstars&quot;, &quot;super&quot;, &quot;highway&quot;, &quot;high&quot;, &quot;way&quot;, &quot;superhighway&quot;);
    Map&lt;String,List&lt;String&gt;&gt; result = wordBreak(data);
    boolean check = result.get(&quot;rockstar&quot;).get(0).equals(&quot;rock star&quot;);
    if(!check)
    {
        return false;
    }
    check = result.get(&quot;rockstar&quot;).get(1).equals(&quot;rocks tar&quot;);
    if(!check)
    {
        return false;
    }
    check = result.get(&quot;rockstars&quot;).get(0).equals(&quot;rock stars&quot;);
    if(!check)
    {
        return false;
    }
    check = result.get(&quot;highway&quot;).get(0).equals(&quot;high way&quot;);
    if(!check)
    {
        return false;
    }
    check = result.get(&quot;superhighway&quot;).get(0).equals(&quot;super high way&quot;);
    if(!check)
    {
        return false;
    }
    check = result.get(&quot;superhighway&quot;).get(1).equals(&quot;super highway&quot;);
    if(!check)
    {
        return false;
    }
    /////////////////////////////////////////////////////////////////////
    Set&lt;String&gt; dict2 = new HashSet&lt;&gt;(Arrays.asList(&quot;c&quot;, &quot;od&quot;, &quot;e&quot;, &quot;x&quot;));
    check = wordBreak(dict2, &quot;code&quot;) &amp;&amp; wordBreak(dict2, &quot;codex&quot;);
    if(!check)
    {
        return false;
    }
    check = wordBreak(dict2, &quot;coder&quot;);
    if(check)
    {
        return false;
    }
    check = wordBreakWithMemoization(dict2, &quot;code&quot;, new HashMap&lt;&gt;());
    if(!check)
    {
        return false;
    }
    return true;
}</pre>
</div></div></td></tr></tbody></table></div><p>Notes:</p><ol><li><p>Always use <code>&lt;=</code> <code>word.length()</code> in for loops since <code>substring </code>second parameter is exclusive</p></li></ol>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Feb 12, 2021 23:36</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
