<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>2-the-react-lifecycle</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="the-react-lifecycle">The React Lifecycle</h1>
    <p>üåëüåíüåìüåîüåï</p>
    <h2 id="objectives">Objectives</h2>
    <ul>
      <li>
        describe the three phases of the React Component Lifecycle (mounting,
        updating, unmounting)
      </li>
      <li>
        properly explain what the <code>constructor</code> and
        <code>render</code> methods do, and what their place is in the React
        Component Lifecycle
      </li>
      <li>
        use the componentDidMount function to set a component‚Äôs state
        post-render
      </li>
      <li>understand the order in which components render and ‚Äúmount‚Äù</li>
      <li>
        bring it all together: use class components and their lifecycle methods
        to:
        <ul>
          <li>
            fetch data asynchronously from an external API (we‚Äôll use axios)
          </li>
          <li>render the data to your app‚Äôs UI</li>
          <li>update the UI when state changes</li>
        </ul>
      </li>
    </ul>
    <h2 id="review-class-components">Review: Class Components</h2>
    <p>
      Here‚Äôs the basic format you‚Äôll use when writing class components in React:
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode javascript"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> Lambda <span class="kw">extends</span> <span class="va">React</span>.<span class="at">Component</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="at">constructor</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">super</span>()<span class="op">;</span> <span class="co">// calls the constructor from React.Component, which intializes this.props</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="co">// initialize this.state here</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="co">// lifecycle methods: componentDidMount, componentDidUpdate, componentWillUnmount, etc.</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="cf">return</span> <span class="op">&lt;</span>h1<span class="op">&gt;</span>Hello<span class="op">,</span> <span class="op">{</span><span class="kw">this</span>.<span class="va">props</span>.<span class="at">name</span><span class="op">}</span>&lt;/h1<span class="op">&gt;;</span></a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="im">export</span> <span class="im">default</span> Lambda<span class="op">;</span></a></code></pre>
    </div>
    <h2 id="what-are-lifecycle-methods">What are lifecycle methods?</h2>
    <p>
      This may feel a bit complex at first, especially coming from the more
      streamlined Hooks approach. An easy way to understand the React lifecycle
      is that it‚Äôs simply ‚Äúwhen a component does what it does, and why‚Äù.
    </p>
    <p>
      Just like a üåø or ü¶î, a React component has three phases to its
      ‚Äúlifecycle‚Äù, and different things need to happen at each stage of life:
    </p>
    <ul>
      <li>üêõ Birth / mounting (<code>componentDidMount</code>)</li>
      <li>ü¶ã Growth / updating (<code>componentDidUpdate</code>)</li>
      <li>üíÄ Death / unmounting (<code>componentWillUnmount</code>)</li>
    </ul>
    <p>
      Sometimes they even render child components üê£ too! But I may be
      overextending a questionable metaphor. Moving on‚Ä¶
    </p>
    <h2 id="render">render()</h2>
    <p>
      If you were to implement the same component as a function and as a class,
      the JSX returned from <code>render()</code> is the same as what you return
      from the function component itself.
    </p>
    <p>Should be a pure function, meaning that it:</p>
    <ul>
      <li>does not modify component state</li>
      <li>returns the same result each time it‚Äôs invoked</li>
      <li>does not directly interact with the browser.</li>
    </ul>
    <h2 id="constructor">constructor()</h2>
    <p>
      For React class components, constructors are only used for two purposes:
    </p>
    <ul>
      <li>
        Initializing local state by assigning an object to
        <code>this.state</code>
      </li>
      <li>Binding event handler methods to an instance.</li>
    </ul>
    <p>
      If you don‚Äôt initialize state and you don‚Äôt bind methods, you don‚Äôt need
      to implement a constructor for your React component. Remember that the
      <code>super()</code> call will happen even if you don‚Äôt write a
      constructor.
    </p>
    <p>
      For initialization, in the constructor we assign
      <code>this.state</code> directly. This is the only place we ever do this!
      In all other methods, use <code>this.setState()</code>.
    </p>
    <h2 id="common-lifecycle-methods">Common lifecycle methods</h2>
    <figure>
      <img
        src="./images/lifecycle-methods.png"
        alt="Lifecycle methods diagram"
      />
      <figcaption>Lifecycle methods diagram</figcaption>
    </figure>
    <p>
      Together, these three lifecycle methods are equivalent to the
      <code>useEffect()</code> hook. Let‚Äôs look at them in detail:
    </p>
    <h3 id="componentdidmount"><code>componentDidMount</code></h3>
    <p>
      invoked after React inserts the component into the DOM. Used to set a
      component‚Äôs state post-render
    </p>
    <h3 id="componentdidupdate"><code>componentDidUpdate</code></h3>
    <p>
      Takes arguments prevProps and prevState, and is called immediately after
      render is finished in each of re-render cycle. Use this for side effects
      like ajax reqeusts.
    </p>
    <p>
      You should always add an if statement to make sure the relevant
      state/props have actually changed before doing anything here. (Otherwise
      you‚Äôll end up with infinite loops!)
    </p>
    <h3 id="componentwillunmount"><code>componentWillUnmount</code></h3>
    <p>
      perform any cleanup, e.g, removing event listeners, invalidating timers or
      cleaning up any DOM elements that were created in
      <code>componentDidMount</code> and <code>componentDidUpdate</code>
    </p>
    <p>
      Use these to setup listeners, fetching data from an API and ultimately
      removing listeners before component is removed (‚Äúunmounted‚Äù) from the DOM.
    </p>
    <h2
      id="in-what-order-do-components-render-and-mount-in-a-react-component-tree"
    >
      In what order do components render and ‚Äúmount‚Äù in a React component tree?
    </h2>
    <p>
      So if you have a bunch of React components, the parent component at the
      top of the tree renders and ‚Äúmounts‚Äù first, right?
    </p>
    <p>
      Not quite! You may be surprised to learn that it actually happens like
      this:
    </p>
    <ul>
      <li>
        Parent component renders, recursively rendering all of the child
        components down the tree
      </li>
      <li>
        The
        <strong>child component at the bottom of the tree mounts first</strong>!
      </li>
      <li>Then the ‚Äúmounting‚Äù propogates back <strong>up</strong> the tree</li>
      <li>Finally, the parent component at the top of the tree mounts last.</li>
    </ul>
    <p>
      I like to visualize this initialization process as a ‚Äúdown-up‚Äù motion, all
      happening in the blink of an eye in most cases. So any
      <code>componentDidMount</code> or <code>useEffect</code> methods toward
      the top of the tree will actually be called <em>after</em> all the
      children components have mounted.
    </p>
    <p>
      This can present a very sneaky bug when you expect data to have been
      passed down to a child component but it‚Äôs undefined becuase the parents
      haven‚Äôt mounted yet! When a child component renders for the first time,
      <strong>none of its parent components have mounted yet</strong>. This
      means that we can‚Äôt count on anything from their lifecycle methods being
      defined yet. This is why we initialize with empty strings and other
      placeholders in the constructor, to make sure child components don‚Äôt ever
      receive <code>undefined</code> values for their props. When someday you
      inevitably come across a mystical-sounding error like this: üòøüö≥
      <code>Uncaught TypeError: Cannot call method 'map' of undefined</code>
      üòøüö≥, checking for undefined props due to this specific render/mount order
      in React should be your first line of defense.
    </p>
    <p>
      To prevent these type errors that randomly crash your app, think about how
      props will change throughout the lifecycle of your components and build in
      some safety checks to avoid accessing values that aren‚Äôt yet defined.
      Especially when there are maps and other type-specific methods involved.
      (Better yet, encourage your team to start using TypeScript! It‚Äôs easy to
      learn, can be added to existing projects incrementally without any heavy
      lifting, and specifically helps prevent errors like this.)
    </p>
    <p>
      Check out the ‚ÄúReact Call Order‚Äù article below for a great intro to this
      advanced concept with some helpful diagrams to explain this ‚Äúdown then
      back up‚Äù render and mount order. Understanding this order of operations
      will save you many hours of debugging the sneakiest bugs in the future!
    </p>
    <h2 id="rarely-used-lifecycle-methods">
      Rarely used lifecycle methods ü¶ñü¶ïüìªüì∫
    </h2>
    <ul>
      <li>getDerivedStateFromProps</li>
      <li>shouldComponentUpdate</li>
      <li>getSnapshotBeforeUpdate</li>
    </ul>
    <p>
      And some others that are deprecated now. Focus on just getting really
      comfortable with the 3 above, as you‚Äôll mainly just see those in most
      cases. If you‚Äôre curious for more historical context though, feel free to
      dig into the React.Component API reference linked below.
    </p>
    <h2 id="understanding-function-components-vs-class-components">
      Understanding function components vs class components:
    </h2>
    <p>
      One simplified way to understand these different styles is that the
      <code>return</code> of a function component is the same as what we return
      from the <code>render()</code> method within a class component. In class
      components we manage state and side effects with these specifically named
      lifecycle methods, while in a function component we use hooks like
      useState() and useEffect() to do the same thing.
    </p>
    <h2 id="more-resources">More Resources</h2>
    <h3 id="videos">Videos</h3>
    <p>
      <a
        href="https://www.youtube.com/watch?v=KDXZibVdiEI&amp;ab_channel=Codevolution"
        >Codevolution - Component Mounting Lifecycle Methods</a
      >
    </p>
    <p>
      <a
        href="https://www.youtube.com/watch?v=deMOuGlpOso&amp;ab_channel=TiffInTech"
        >Tiff in Tech - React Lifecycle Explained</a
      >
    </p>
    <p>
      <a
        href="https://www.youtube.com/watch?v=9kSXwj_K-6o&amp;ab_channel=LevelUpTuts"
        >React 16 For Everyone #6 - LifeCycle Methods</a
      >
    </p>
    <h3 id="articles">Articles</h3>
    <p>
      <a
        href="https://dev.to/prototyp/react-useeffect-explained-with-lifecycle-methods-296n"
        >useEffect explained with lifecycle methods</a
      >
    </p>
    <p>
      <a
        href="https://medium.com/better-programming/understanding-the-useeffect-dependency-array-2913da504c44"
        >Understanding the useEffect Dependency Array</a
      >
    </p>
    <p>
      <a href="https://reactjs.org/docs/react-component.html"
        >React.Component lifecycle methods - API reference</a
      >
    </p>
    <p>
      <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/"
        >Interactive lifecycle method diagram</a
      >
    </p>
    <p>
      <a href="https://blog.logrocket.com/post-hooks-guide-react-call-order/"
        >React Call Order</a
      >
    </p>
    <p>
      <a
        href="https://medium.com/react-ecosystem/react-components-lifecycle-ce09239010df"
        >React component‚Äôs lifecycle - Medium article</a
      >
    </p>
    <p>
      <a
        href="https://www.notion.so/React-b4e93c23ea164f08a54622c3f6b40912?p=f37ae29e99564a89be8b0918c02ef974"
        >Lifecycle Methods &amp; Side Effects - by TL Megan Miller</a
      >
    </p>
    <p>
      <a href="https://www.notion.so/this-a82f4b18e0ba427b8e38e6b86daf645c"
        >this - by TL Megan Miller</a
      >
    </p>
  </body>
</html>
