<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
    <head>
        <meta charset="utf-8" />
        <meta name="generator" content="pandoc" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=yes"
        />
        <title>README</title>
        <style type="text/css">
            code {
                white-space: pre-wrap;
            }
            span.smallcaps {
                font-variant: small-caps;
            }
            span.underline {
                text-decoration: underline;
            }
            div.column {
                display: inline-block;
                vertical-align: top;
                width: 50%;
            }
        </style>
    </head>
    <body>
        <h1 id="application-recipe">Application Recipe</h1>
        <p>
            <strong
                >Note: This is the order in which I built this app. Hence it is
                just F.Y.I.</strong
            >
        </p>
        <h2 id="prerequisite">Prerequisite</h2>
        <h3 id="workflow">Workflow</h3>
        <p>
            Generally, the workflow of this application is pretty
            straightforward: 1. User type in the <code>username</code> (default
            to <code>'Ninja Cat'</code>) 2. Create a session for the user with
            the initial cash of $100 3. User set the bet and start the round 4.
            Generate poker hands for the bot and the user 5. Compare both poker
            hands, determine the winner and update the cash 6. Show result 7.
            User may start another round (goto step 3) or “cash out” (goto step
            1) ### Structure Consider the modules that we need to build this
            application. Here is what I thought by then: - A Session module that
            handles user name and cash - A Player module that handles player’s
            hand (cards that the player holds). This turned out to be the Game
            module - A Poker service that handles the logic of determining poker
            hand type and comparing poker hand - Also, we’ll need some place to
            cache the poker that has appeared so far. This is implemented in the
            Deck module
        </p>
        <h2 id="generate-card">Generate card</h2>
        <ol type="1">
            <li>
                Consider types, as per TypeScript. Poker hand (either the
                player’s or the bot’s) are nothing but several poker cards, with
                each generated randomly. Deck is just bunch of poker cards. That
                said, we need a <code>PokerCard</code> class. Some may consider
                its better to name it as an interface. But I opt-in for class
                due to its versatility, and the ability to use it as a
                constructor. In my code, I name it as <code>Poker</code>
            </li>
            <li>
                So, how should we identify a real poker card? Simple, just
                <code>suit</code> (Spade, Heart, Club and Diamond) and
                <code>value</code> (from 2 to A). Both will be the attributes of
                <code>Poker</code>. In the application, here is what we’ve got
                so far:
                <ul>
                    <li>
                        <code>CardSuit</code> and <code>CardValue</code> as
                        <code>enum</code>
                    </li>
                    <li>
                        <code>Card</code> as in <code>class</code>, this is the
                        “PokerCard” mentioned above
                    </li>
                </ul>
            </li>
            <li>
                It is obvious that both <code>PokerHand</code> and
                <code>Deck</code> are <code>Poker[]</code> (some prefers the
                other notation <code>Array&lt;Poker&gt;</code>), despite their
                difference in the <code>Poker</code> quantity
            </li>
            <li>
                Then, we may start working on the logic of generating random
                cards. Note that this action is related to the
                <code>Deck</code> as well. We don’t want an Ace of Spade to
                appear twice on the table, nor do we want to overuse the deck.
                That’s the reason why we need to keep a <code>cache</code> in
                the deck. For every card that is randomly generated, we’ll save
                its suit and value to the <code>cache</code>
            </li>
            <li>
                In order to prevent generating duplicate cards, we’ll need to
                check if the card is already generated in the
                <code>cache</code> object. If it is, just create another random
                card. It won’t take hundreds of times before you get a valid
                card, no worries
            </li>
            <li>
                Moreover, I decided to do a “reshuffle” when certain amount of
                cards are plucked out from the current deck. Since I noticed in
                the real casino, they never use up a full deck of card. So,
                we’ll need to keep a counter (named <code>count</code>) in the
                <code>Deck</code> module as well. As you may guess, “reshuffle”
                is just clearing/resetting the cache object, simple yet
                practical
            </li>
        </ol>
        <h2 id="compare-card">Compare card</h2>
        <h3 id="cases">Cases</h3>
        <ol type="1">
            <li>
                There are altogether 11 poker hands, ranked from high to low
                (though, depending on the rule, Wheel and Steel Wheel may not
                apply):
                <ol type="1">
                    <li>
                        Straight flush (including Royal Flush, which is the
                        highest)
                    </li>
                    <li>
                        Steel wheel (a straight that starts with an A, then 2,
                        3, 4, 5. All in the same suit)
                    </li>
                    <li>Four of a kind</li>
                    <li>Full house</li>
                    <li>Flush</li>
                    <li>Straight</li>
                    <li>
                        Wheel (a straight that starts with an A, then 2, 3, 4,
                        5)
                    </li>
                    <li>Three of a kind</li>
                    <li>Two pair</li>
                    <li>One pair</li>
                    <li>High card</li>
                </ol>
            </li>
            <li>
                The High Card should always be determined as an “else” (or
                “fallback”) case. That said, when checks for all other poker
                hands (e.g. straight, one pair, full house, etc.) fail, then we
                can conclude that it is a High Card
            </li>
            <li>
                The logic to check for flush is tricky, especially for
                multi-deck game. For example, a two-deck game may form One Pair
                or Two Pair while it is still Flush at the same time. Since
                Flush ranks higher than either One Pair or Two Pair, checking
                for Flush should happen prior to determining One Pair or Two
                Pair
            </li>
            <li>
                Honestly, it is much easier for single-deck game, which is the
                rule that this app goes by. In this case, any poker hands other
                than Straight or its alike above High Card cannot be a Flush
                (Flush itself excluded, for sure). Hence, we just need to handle
                the logic of Steel Wheel and Straight Flush ### Methodology
            </li>
            <li>
                Regarding a poker hand to be determined, it will be beneficial
                if we “massage” the data first. As mentioned above,
                <code>PokerHand</code> is <code>Poker[]</code> while
                <code>Poker</code> is simply an object with attributes
                <code>suit</code> and <code>value</code>
            </li>
            <li>
                Further more, consider the following cases:
                <ul>
                    <li>
                        If there is only 1 kind of suit in a poker hand, then it
                        is a Flush
                    </li>
                    <li>
                        If there are 4 different values in a poker hand, then it
                        must be a One Pair. e.g. player has
                        <code>[5Spade, 2Club, 4Spade, 2Diamond, 9Heart]</code>,
                        the values are <code>[5, 2, 4, 2, 9]</code>. Hence there
                        are 4 different kinds of values
                    </li>
                    <li>
                        If there are 3 different values in a poker hand, then it
                        could be a Three of a kind, or it could also be a Two
                        Pair as well
                    </li>
                    <li>
                        If there are 2 different values in a poker hand, then it
                        could be a Four of a kind, or it could also be a Full
                        House
                    </li>
                </ul>
            </li>
            <li>
                The above cases introduce us to a crucial statement:
                <strong
                    >We need to get the count of the suit(s) and value(s) in a
                    poker hand</strong
                >
            </li>
            <li>
                Consider the following cases:
                <ul>
                    <li>
                        When both the player and the bot have High Card, to
                        determine the winner, we need to compare the largest
                        card. If it is identical, we move to comparing the
                        second largest card, then the third, etc. If all cards
                        are identical in card value, it is a draw
                    </li>
                    <li>
                        When both the player and the bot have Two Pairs, to
                        determine the winner, we need to compare the largest
                        pair, then the second largest pair, then the single
                        card. If all are identical, it is a draw
                    </li>
                    <li>…and so on</li>
                </ul>
            </li>
            <li>
                The above cases lead to another crucial statement:
                <strong
                    >We need to sort each poker hand values for
                    comparison</strong
                >
                ### Implementation of poker hand type determination
            </li>
            <li>
                Some of the poker hands are easy to determine:
                <ul>
                    <li>
                        When a poker hand is both a Straight and a Flush, then
                        it is a Straight Flush
                    </li>
                    <li>
                        When a poker hand is both a Wheel and a Flush, then it
                        is a Steel Wheel
                    </li>
                    <li>
                        When a poker hand is a Wheel/Straight/Flush
                        <strong>ONLY</strong>, then it is a
                        Wheel/Straight/Flush, respectively
                    </li>
                </ul>
            </li>
            <li>
                Apparently, we’ll need to build several functions for each
                check:
                <ul>
                    <li>
                        <code>isStraight</code>: iterate through the poker hand
                        and check if card value is consecutive by comparing the
                        adjacent ones
                    </li>
                    <li>
                        <code>isWheel</code>: since the only case for Wheel is
                        <code>[2, 3, 4, 5, A]</code>, I decided to perform this
                        check specifically
                    </li>
                    <li>
                        <code>isFlush</code>: when the count of Suit is equal to
                        <code>1</code> (i.e. only one Card Suit in the poker
                        hand), it is a Flush
                    </li>
                </ul>
            </li>
            <li>
                For the rest, e.g. when there are altogether 2 different values
                in the poker hand, since it could be a Four of a kind, or it
                could be a Full House. But we should be able to tell if we can
                calculate the count of values. For Four of a kind, the count of
                values must be <code>4</code> and <code>1</code>. While for Full
                House, the count of values is <code>3</code> and <code>2</code>.
                Likewise, we could determine Three of a kind and Two Pair in
                this way.
                <ul>
                    <li>
                        When <code>valueCount</code> is <code>2</code>
                        <ul>
                            <li>
                                When count of values includes <code>4</code>, it
                                is Four of a kind
                            </li>
                            <li>Or else, it is a Full House</li>
                        </ul>
                    </li>
                    <li>
                        When <code>valueCount</code> is <code>3</code>
                        <ul>
                            <li>
                                When count of values includes <code>3</code>, it
                                is Three of a kind
                            </li>
                            <li>Or else, it is a Two Pair</li>
                        </ul>
                    </li>
                    <li>
                        When <code>valueCount</code> is <code>4</code>
                        <ul>
                            <li>It is a One Pair</li>
                        </ul>
                    </li>
                    <li>
                        Else, it is High Card ### Implementation of winner
                        determination
                    </li>
                </ul>
            </li>
            <li>Compare the hand type. Higher hand type always wins</li>
            <li>
                If both the player and the bot have the same hand type
                <ol type="1">
                    <li>
                        Compare starting from the largest “special” card. For
                        example, the largest pair in Two Pair, the three-card in
                        Full House
                    </li>
                    <li>
                        Compare second largest “special” card, if any. For
                        example, the second largest pair in Two Pair
                    </li>
                    <li>
                        Compare the largest “normal” card. For example, the
                        largest single card in One Pair
                    </li>
                    <li>
                        Compare the second largest “normal” card, if any. For
                        example, the second largest single card in One Pair
                    </li>
                    <li>…and so on</li>
                </ol>
            </li>
            <li>If everything is identical, then it is a Draw</li>
        </ol>
        <h1 id="some-random-thoughts">Some Random Thoughts</h1>
        <h2 id="singleton">Singleton</h2>
        <ul>
            <li>
                There will be only one player in this game, hence only one
                <code>Session</code> is needed
            </li>
            <li>
                Since there is only one <code>Session</code>, it makes sense to
                have only one <code>Deck</code> as well
            </li>
            <li>
                <code>CardService</code> handles the logic of generating cards
                and the calculation of rank. Its instance is created upon using,
                a.k.a. lazy initialization. There is no need to make multiple
                instances co-exist. Hence the name “service” rather than
                “factory”
            </li>
            <li>
                Classes under <code>util</code> are similar to the services. No
                multiple instance is needed ## Barrel files
            </li>
            <li>
                Personally, I consider
                <a href="https://basarat.gitbook.io/typescript/main-1/barrel"
                    >barrel file</a
                >
                to be beneficial. With the help of barrel file, we don’t have to
                specify the exact file that we are looking for when we
                <code>import</code> something. Normally, we are pretty sure
                which folder the thing we are looking for resides in
            </li>
        </ul>
    </body>
</html>
